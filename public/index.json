[{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像；\n如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png) 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像；\n如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png) 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像；\n如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png) 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png) 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png) 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png) 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png) 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png) 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK\n测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装\nadb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2 ![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted image 20250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； ![Pasted image 20250702102345](./Pasted image 20250702102345.png)\n选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； 点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； 点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； 点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； ![Pasted image 20250702102152](./Pasted image 20250702102152.png)\n选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； 点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； 点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted%20image%2020250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； 点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted%20image%2020250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted%20image%2020250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted%20image%2020250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； ![Pasted%20image%2020250702102515](./Pasted image 20250702102515.png)\n设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； ![Pasted image 20250702102601](./Pasted image 20250702102601.png)\n点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； ![Pasted image 20250702102835](./Pasted image 20250702102835.png)\n编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 ![Pasted image 20250702161614](./Pasted image 20250702161614.png)\nAPK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n![Pasted image 20250702161632](./Pasted image 20250702161632.png)\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； 点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:50570/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:50570/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION\r* Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字\rwsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:50570/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:50570/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:50570/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt;\rgit clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git\r├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件\r│ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。\r├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等\r├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心\r├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。\r├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。\r├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。\r├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。\r├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。\r└─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。\rhugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod\rgit submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址\rlanguageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言\rtheme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod\rtitle = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题\r[outputs]\rhome = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;]\r# -- 导航栏菜单配置 --\r# 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页\r[[menu.main]]\ridentifier = \u0026#34;archives\u0026#34;\rname = \u0026#34;归档\u0026#34;\rurl = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md\rweight = 10 # 权重，数字越小越靠前\r[[menu.main]]\ridentifier = \u0026#34;search\u0026#34;\rname = \u0026#34;搜索\u0026#34;\rurl = \u0026#34;/search/\u0026#34;\rweight = 20\r[[menu.main]]\ridentifier = \u0026#34;tags\u0026#34;\rname = \u0026#34;标签\u0026#34;\rurl = \u0026#34;/tags/\u0026#34;\rweight = 30 在content下面创建archives.md和search.md，然后补充内容 ---\rtitle: \u0026#34;Archives\u0026#34;\rlayout: \u0026#34;archives\u0026#34;\r# archives.md`\r# 不要改动这个文件的其他内容\r--- ---\rtitle: \u0026#34;Search\u0026#34;\rlayout: \u0026#34;search\u0026#34;\r# search.md\r# 不要改动这个文件的其他内容\r--- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼──\rPages │ 13\rPaginator pages │ 0\rNon-page files │ 0\rStatic files │ 0\rProcessed images │ 0\rAliases │ 2\rCleaned │ 0\rBuilt in 230 ms\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add .\rgit commit -m \u0026#34;First Add\u0026#34;\rgit push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches: [\u0026#34;main\u0026#34;]\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \u0026#34;pages\u0026#34;\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\renv:\rHUGO_VERSION: 0.150.0\rsteps:\r- name: Install Hugo CLI\rrun: |\rwget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r\u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb\r- name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v4\rwith:\rsubmodules: recursive\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v5\r- name: Install Node.js dependencies\rrun: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34;\r- name: Build with Hugo\renv:\rHUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache\rHUGO_ENVIRONMENT: production\rrun: |\rhugo \\\r--minify \\\r--baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34;\r- name: Upload artifact\ruses: actions/upload-pages-artifact@v3\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:50570/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"}]