[{"content":" 本篇文章主要是针对8775官方文档中的System Performance一章里面内容，学习文档中的性能测试工具用法。尽量结合高通文档《80-72626-100 Software Developer Resources for SA7255P, SA8255P, SA8620P, SA8650P, SA8775P HQX \u0026amp; QX Software Products》一起查看。 2025-07-24\nSystem Performance的主要内容：\n如何挑选合适的Profiler工具（哪些工具能测哪些）； 命令行工具 2 种 （SysProfiler、Sysmon）、 GUI工具两种（Snapdragon Profiler、Qprofiler） 具体的Profiler工具的使用指南（包括Qprofiler、SysProfiler和两种安卓通用的工具）； QProfiler 安装： 从QPM上搜索Qualcomm Profiler安装即可；\n需要使用管理员打开QPM； 安装有点慢，需要耐心等待； 可以做什么? QProfiler可以连接Android QNX等等系统，Android使用ADB即可； 调研目前只尝试了Android系统，QProfiler可以看到SoC温度、CPU、内存、GPU、IO速度的实时指标，但是无法具体看进程等等细节，作为系统性能工具进行检测，尤其是GPU和IO； 怎么使用？ 方案1 adb连接好 连接WiFi，电脑也连接这个WiFi； 或者用网线直接连接（公司电脑以太网口好像是被禁用的，无法使用），最终目的是组成可以正常运行的局域网； 运行\u0026quot;C:\\Program Files (x86)\\Qualcomm\\Shared\\QualcommProfiler\\API\\target-la\\InstallerLA.exe\u0026quot; （8775 Android是对应target-la，其他的按照官方文档进行选择） 运行QProfiler \u0026ldquo;C:\\Program Files (x86)\\Qualcomm\\QualcommProfiler\\GUI\\qcprofiler.exe\u0026rdquo; 填写车机Android的IP，端口填写62472； 连接上之后选择指标、参数进行检测； 方案2 adb连接好； 运行\u0026quot;C:\\Program Files (x86)\\Qualcomm\\Shared\\QualcommProfiler\\API\\target-la\\InstallerLA.exe\u0026quot; （8775 Android是对应target-la，其他的按照官方文档进行选择） adb shell 输入以下命令 export QMONITOR_BACKEND_LIB_PATH=/vendor/qprof/backends export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/vendor/qprof/libs/ qprof --configure --server-ip 127.0.0.1 --port 9999 qprof --start-server adb forward tcp:9999 tcp:9999 运行QProfiler \u0026ldquo;C:\\Program Files (x86)\\Qualcomm\\QualcommProfiler\\GUI\\qcprofiler.exe\u0026rdquo; 填写 127.0.0.1 ，端口填写 9999； 连接上之后选择指标、参数进行检测； 更多说明：\n高通文档 80-54323-2 软件ABOUT里面的文档 基于gRPC框架实现，实际在机器开启服务端，局域网内工具通过获取机器数据\nSnapdragon Profiler 安装 从QPM下载，安装包下载好之后安装即可； 安装好之后，还不可以直接使用，需要按照\u0026quot;Snapdragon Profiler\\README-gtk.txt\u0026quot;下的Installation instructions安装GTK3； ----------------------- WINDOWS ----------------------- Windows users should run the Snapdragon Profiler installer (with an internet connection) and follow the prompts to install Gtk3. Alternate instructions: 1. Install gtk+3 Download, unzip, and place in %LOCALAPPDATA%\\Gtk\\3.24.24: https://github.com/GtkSharp/Dependencies/raw/master/gtk-3.24.24.zip 2. Go to https://www.nuget.org/downloads and download the recommended version of nuget.exe under \u0026#34;Windows x86 Commandline\u0026#34; 3. Install gtk#3 Open a command prompt \u0026gt; cd to your downloads directory \u0026gt; nuget.exe install gtksourcesharp -Version 3.24.24.38 -OutputDirectory %LOCALAPPDATA%\\SDP 4. If you have installed Snapdragon Profiler to a directory that requires elevated privileges (like Program Files), Profiler cannot automatically copy gtk#3 to its root directory for you on startup. You must copy the 8 dlls yourself from i.e. %LOCALAPPDATA%\\SDP\\AtkSharp.3.24.24.38\\lib\\netstandard2.0\\AtkSharp.dll =\u0026gt; C:\\Program Files (x86)\\Qualcomm\\Snapdragon Profiler\\AtkSharp.dll. 可以做什么？ Trace采集； 实时性能分析； CPU采样； GPU帧捕获； 相关的性能指标比QProfiler会多，从Android性能检测的指标来看，可以按照捕获具体进程的指标，进程指标可以捕获CPU和内存，系统指标可以捕获CPU、GPU、内存、网络（主要为WiFi） 使用 Android adb连接正常 按照文档，adb shell setprop vendor.egl.profiler 1 配置可以检测； 不同的系统有不同的配置方法，具体见软件的文档参考； Profiler File-Connect自动检测到，点击Connect连接即可； 按照页面自行捕获数据即可； 其他系统尚无尝试过，页面需要填入HOST IP地址，应该也是需要组成局域网才可以；\n参考文档：\n软件Help中的文档； 高通文档 80-PG469-15 高通文档 80-71528-1 高通文档 80-72626-100 《Software Developer Resources for SA7255P, SA8255P, SA8620P, SA8650P, SA8775P HQX \u0026amp; QX Software Products》 SystemPerformace一章 SysProfiler命令行工具 安装 QNX镜像内置的sysprofiler_app，只可以测QNX Linux Android（LA/LV Mental、 LA/LV GVM）的指标， 需要提CASE向高通获取； 可以做什么？ 图中的指标都可以测试，有选项可以生成Profetto能看的json文件，也可以生成CSV等等； 如何使用 直接命令行使用 具体参数说明，见高通文档 80-72626-100 《Software Developer Resources for SA7255P, SA8255P, SA8620P, SA8650P, SA8775P HQX \u0026amp; QX Software Products》 SystemPerformace \u0026ndash; Usage guide for profling tools \u0026ndash; SysProfiler Sysmon命令行工具 安装 无需安装，QNX系统内置 sysMonAppQNX 可以做什么？ 没有详细的user guide文档，以下摘自 80-72626-100 一段翻译： valeosysMonApp 是一个 QNX 可执行文件，它通过 FastRPC 与 aDSP、cDSP、mDSP、sDSP 或 NPU 子系统上的 Q6 进行交互，并为用户提供分析 Q6 工作负载、获取时钟信息、设置或删除核心和总线时钟、获取软件线程信息以及获取软件线程级配置文件统计信息等功能。 支持的作系统包括 LA GVM、LA metal、QNX 和 HGY。 指标：Sysmon 详细指标 使用 QNX串口直接运行即可，没有专门文档说明，只能看\u0026ndash;help参考； 从描述来看Android应该用不上，有关联的部分只有上面 支持的工作系统包括LA GVM； 查阅后Q6主要是DSP相关性能，教程可查看高通 VD80-50431-501 ； 参考文档 80-72626-100 《Software Developer Resources for SA7255P, SA8255P, SA8620P, SA8650P, SA8775P HQX \u0026amp; QX Software Products》 KBA-240602194851《How to use sysmonapp on HQX》 VD80-50431-501 How to use sysmonapp on HQX视频 80-54323-2 Qualcomm Profiler User Guide KBA-220422011853 How to capture and parse sensor‘s sysMonapp log correctly Snapdragon Profiler User Guide - Automotive Platform.pdf 软件内文档 Snapdragon Profiler User Guide.pdf 软件内文档 QCP User Guide.pdf 软件内文档 ","permalink":"http://localhost:1313/posts/%E9%AB%98%E9%80%9A8775%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E8%B0%83%E7%A0%94/","summary":"高通8775性能测试工具调研","title":"高通8775性能测试工具调研"},{"content":"\ncomm_manager/src/CommunicationManager.o.d -o out/soong/.intermediates/hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/LibCommManager/android_vendor.34_arm64_armv8-a-branchprot_static_cfi/obj/hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_manager/src/CommunicationManager.o hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_manager/src/CommunicationManager.cpp In file included from hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_manager/src/CommunicationManager.cpp:3: In file included from hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_soa/include/CommunicationSOAImpl.h:5: In file included from hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_soa/src-gen/v2/commonapi/CanInfoTypes.hpp:21: In file included from external/capicxx-core-runtime/include/CommonAPI/InputStream.hpp:21: In file included from external/capicxx-core-runtime/include/CommonAPI/Variant.hpp:23: external/capicxx-core-runtime/include/CommonAPI/Logger.hpp:31:37: error: \u0026#39;visibility\u0026#39; attribute ignored when parsing type [-Werror,-Wignored-attributes] enum class Level : std::uint8_t COMMONAPI_EXPORT { ^~~~~~~~~~~~~~~~ external/capicxx-core-runtime/include/CommonAPI/Export.hpp:19:46: note: expanded from macro \u0026#39;COMMONAPI_EXPORT\u0026#39; #define COMMONAPI_EXPORT __attribute__ ((visibility (\u0026#34;default\u0026#34;))) ^~~~~~~~~~~~~~~~~~~~~~ 1 error generated. 11:37:46 ninja failed with: exit status 1 Solution // bp添加 -Wno-attributes -Werror ","permalink":"http://localhost:1313/posts/error-visibility-attribute-ignored-when-parsing-type--werror-wignored-attributes/","summary":"Error Visibility Attribute Ignored When Parsing Type  Werror, Wignored Attributes","title":"Error Visibility Attribute Ignored When Parsing Type  Werror, Wignored Attributes"},{"content":"现象： 编译镜像没有super.img\n排查过程： 脚本中generate_super报错，无法找到otatools等工具，对比正常情况，工具在lagvm_qssi下的out/dist/目录下 \u0026mdash;\u0026gt; qssi编译失败； 直接编译qssi系统， ./build.sh dist -j32 \u0026ndash;qssi_only， 出现报错： 出现的so库loading失败，基本so库都是libncurses.so.5，相关工具比较多像是编译工具，如llvm等； 解决办法 重装libncurses5即可；\nsudo apt-get install libncurses5 ","permalink":"http://localhost:1313/posts/libncurses5%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/","summary":"libncurses5编译报错","title":"libncurses5编译报错"},{"content":"现象 黑屏，无法开机\n原因 本质原因：CameraServer启动失败导致\n日志 --------- beginning of crash 01-01 08:00:29.415 755 755 F linker : CANNOT LINK EXECUTABLE \u0026#34;/system/bin/app_process64\u0026#34;: \u0026#34;/system/lib64/lib-platform-compat-native-api.so\u0026#34; has bad ELF magic: bd4d2356 01-01 08:00:29.416 368 368 I hwservicemanager: getTransport: Cannot find entry android.system.net.netd@1.1::INetd/default in either framework or device VINTF manifest. 01-01 08:00:29.416 753 753 E HidlServiceManagement: Service android.system.net.netd@1.1::INetd/default must be in VINTF manifest in order to register/get. 01-01 08:00:29.416 753 753 E Netd : Unable to start HIDL NetdHwService: -2147483648 01-01 08:00:29.416 753 753 I netd : Registering NetdHwService: 7665us 01-01 08:00:29.416 753 753 I netd : Netd started in 182666us 01-01 08:00:30.532 788 788 D vdc : Waited 0ms for vold 01-01 08:00:29.676 794 794 I wificond: wificond is starting up... 01-01 08:00:29.688 361 799 W libc : Unable to set property \u0026#34;ctl.interface_start\u0026#34; to \u0026#34;aidl/android.hardware.net.nlinterceptor.IInterceptor/default\u0026#34;: error code: 0x20 01-01 08:00:29.701 789 789 F linker : CANNOT LINK EXECUTABLE \u0026#34;/system/bin/audioserver\u0026#34;: \u0026#34;/system/lib64/lib-platform-compat-native-api.so\u0026#34; has bad ELF magic: bd4d2356 01-01 08:00:29.704 791 791 F linker : CANNOT LINK EXECUTABLE \u0026#34;/system/bin/cameraserver\u0026#34;: \u0026#34;/system/lib64/lib-platform-compat-native-api.so\u0026#34; has bad ELF magic: bd4d2356 ","permalink":"http://localhost:1313/posts/android-cameraserver%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%BC%80%E6%9C%BA%E9%97%AE%E9%A2%98/","summary":"Android CameraServer导致无法开机问题","title":"Android CameraServer导致无法开机问题"},{"content":"现象： Launcher崩溃，黑屏重启 分析： 直接原因：Launcher崩溃 原因： AMS中判断U10用户过多Binder，导致U10用户的进程被回收。正常Bidner应该不会过多，一般是APP操作不当导致。 04-11 01:07:00.934 1292 1386 I ActivityManager: Killing 2575:com.maxj.app.maxjlauncher/u10s1000 (adj 0): Too many Binders sent to SYSTEM 04-11 01:07:00.934 1292 1386 I am_kill : [10,2575,com.maxj.app.maxjlauncher,0,Too many Binders sent to SYSTEM] 继续排查日志，发现ConnectivityManager一直在打印 Line 30294: 04-11 01:04:12.969 2915 2915 E ConnectivityManager: NetworkCallback was already registered Line 30297: 04-11 01:04:12.976 2915 2915 E NetworkChangeListener: startListening: null Line 30298: 04-11 01:04:12.976 2915 2915 E ConnectivityManager: NetworkCallback was already registered Line 30301: 04-11 01:04:12.982 2915 2915 E NetworkChangeListener: startListening: null 定位PID进程为txzadapter，通知APP解决；\n","permalink":"http://localhost:1313/posts/too-many-binders-sent-to-system/","summary":"Too Many Binders Sent to SYSTEM","title":"Too Many Binders Sent to SYSTEM"},{"content":"报错 [ 50% 1/2] Creating Bazel symlink forest Clang SA is not enabled [100% 2/2] analyzing Android.bp files and generating ninja file at out/soong/build.ninja FAILED: out/soong/build.ninja cd \u0026#34;$(dirname \u0026#34;out/host/linux-x86/bin/soong_build\u0026#34;)\u0026#34; \u0026amp;\u0026amp; BUILDER=\u0026#34;$PWD/$(basename \u0026#34;out/host/linux-x86/bin/soong_build\u0026#34;)\u0026#34; \u0026amp;\u0026amp; cd / \u0026amp;\u0026amp; \u0026#34;$BUILDER\u0026#34; --top \u0026#34;$TOP\u0026#34; --soong_out \u0026#34;out/soong\u0026#34; --out \u0026#34;out\u0026#34; -o out/soong/build.ninja --bazel-mode --globListDir build --globFile out/soong/globs-build.ninja -t -l out/.module_paths/Android.bp.list --available_env out/soong/soong.environment.available --used_env out/soong/soong.environment.used.build Android.bp Clang SA is not enabled internal error: bazel command failed: fork/exec ./build/bazel/bin/bazel: no such file or directory ---command--- ./build/bazel/bin/bazel --output_base=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/out/bazel/output cquery deps(@soong_injection//mixed_builds:buildroot, 2) --profile=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/out/bazel_metrics/cquery-buildroot_bazel_profile.gz --experimental_repository_disable_download --ui_event_filters=-INFO --noshow_progress --norun_validations --output=starlark --starlark:file=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/out/soong/soong_injection/buildroot.cquery ---env--- QIIFA_BUILD_CONFIG=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/out/QIIFA_BUILD_CONFIG/build_config.xml OLDPWD=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/out/host/linux-x86/bin SDCLANG_SA_ENABLED= SDCLANG_AE_CONFIG=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/vendor/qcom/proprietary/common-noship/etc/sdclang.json TOP=/home/l-zliang16/8775/lagvm_qssi/LINUX/android SDCLANG_CONFIG=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/vendor/qcom/proprietary/common/config/sdclang.json PWD=/ TARGET_BOARD_PLATFORM=qssi HOME=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/out/bazel/bazelhome PWD=/proc/self/cwd BUILD_DIR=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/out/soong OUT_DIR=/home/l-zliang16/8775/lagvm_qssi/LINUX/android/out BAZEL_DO_NOT_DETECT_CPP_TOOLCHAIN=1 ---stderr--- --- 11:03:07 soong bootstrap failed with: exit status 1 #### failed to build some targets (39 seconds) #### 解决办法： 1.先清理中间文件 # make clean 2.再编译即可 # make -j12 参考： Android14之解决编译报错:bazel: no such file or directory(一百八十九)_bazel之后找不到路径-CSDN博客 补充 20251010补充\n最近发现，如果报错是bazel问题，平时编译也没问题的话，一般是Android目录被修改了。怀疑bazel的一些环境变量等等，跟Android目录有关。 ","permalink":"http://localhost:1313/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-forkexec-.buildbazelbinbazel-no-such-file-or-directory/","summary":"编译报错 fork/exec ./build/bazel/bin/bazel: no such file or directory","title":"编译报错 fork/exec ./build/bazel/bin/bazel: no such file or directory"},{"content":"Date：2024/12/16\n问题 按照既定教程，repo拉取代码的时候过大，加上生成物后1T磁盘已无法满足，但是存在其他同事代码拉取很小的情况\n解决办法 repo init加上\u0026ndash;depth=1参数，进行浅拷贝 repo init --current-branch --depth=1 -u \u0026lt;url\u0026gt; -m mainifest.xml --no-clone-bundle --repo-url=https://git.codelinaro.org/clo/la/tools/repo.git --repo-branch=qc-stable repo sync -j32 -c --no-tags 排查过程 主要思路是通过对比代码占用很大的工作站（后称大工作站）和代码占用很小的工作站（后称小工作站）进行对比 Mainifest的Git Log 大工作站：.repo/mainifests/下面git log仅有1条，且有grafted字样\n小工作站：.repo/mainifests/下面git log有完整历史，没有grafted字样\ngrafted字样是什么？ https://adoyle.me/Today-I-Learned/git/grafted-commit.html ![[Pasted image 20250320102120.png]] \u0026ndash;depth参数是什么？怎么用？ https://blog.csdn.net/qq_43827595/article/details/104833980 怎么查看大小工作站的depth 查询AI，无果 是否为git的配置？如何查看git的配置？ https://www.cnblogs.com/merray/p/6006411.html # 查看系统配置 git config --system --list # 查看当前用户（global）配置 git config --global --list # 查看当前仓库配置信息 git config --local --list manifests里面git config \u0026ndash;local \u0026ndash;list，明显看到repo.depth = 1 repo能否\u0026ndash;depth？\u0026ndash;\u0026gt; 查看\u0026ndash;help repo init能， repo sync不能指定 加一下试试看咯 —\u0026gt; BINGO 其他的一些问题？ 如何识别git的浅克隆和深克隆？ 检查.git/shallow，有此文件是浅拷贝，无则深拷贝； git rev-parse \u0026ndash;is-shallow-repository，true是浅拷贝，false是深拷贝 repo如何保证是浅克隆 添加\u0026ndash;depth=选项（暂时没有找到别的办法了） git浅拷贝后 git log只能看到1条日志，如何看到全部日志，但保持浅拷贝？ 方法1：git fetch \u0026ndash;depth= 方法2：git fetch origin \u0026ndash;unshallow 浅克隆和深克隆的区别和定义 浅克隆（Shallow Clone）：\n定义：浅克隆是指在克隆 Git 仓库时，仅获取指定数量的最近提交，而不获取完整的提交历史。通常通过 \u0026ndash;depth 选项来指定克隆的深度； 使用场景：浅克隆适用于需要快速获取代码进行构建或测试，但不需要完整历史记录的场合。例如，在 CI/CD 环境中，通常只关心最新的代码而不需要历史提交。 深克隆（Deep Clone）：\n定义：深克隆是指在克隆 Git 仓库时，获取整个仓库的完整提交历史。没有使用 \u0026ndash;depth 选项； 使用场景：深克隆适用于需要完整历史记录的场合，如开发和调试时，开发者可能需要查看项目的历史变更和提交。 ","permalink":"http://localhost:1313/posts/repo%E6%8B%89%E5%8F%96%E4%BB%A3%E7%A0%81%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/","summary":"repo拉取代码占用过大问题排查","title":"repo拉取代码占用过大问题排查"},{"content":"Signature privileged permissions not in privapp-permissions allowlist{com.android.car.carlauncher (systempriv-appCarLauncher.apk) android.permission.SET_WALLPAPER_COMPONENT}\n10-07 02:32:36.488 14748 14748 E System : ****************************************** 10-07 02:32:36.488 14748 14748 E System : ************ Failure starting system services 10-07 02:32:36.488 14748 14748 E System : java.lang.IllegalStateException: Signature|privileged permissions not in privapp-permissions allowlist: {com.android.car.carlauncher (/system/priv-app/CarLauncher.apk): android.permission.SET_WALLPAPER_COMPONENT} 10-07 02:32:36.488 14748 14748 E System : at com.android.server.pm.permission.PermissionManagerServiceImpl.onSystemReady(PermissionManagerServiceImpl.java:4447) 10-07 02:32:36.488 14748 14748 E System : at com.android.server.pm.permission.PermissionManagerService$PermissionManagerServiceInternalImpl.onSystemReady(PermissionManagerService.java:743) 10-07 02:32:36.488 14748 14748 E System : at com.android.server.pm.PackageManagerService.systemReady(PackageManagerService.java:4265) 10-07 02:32:36.488 14748 14748 E System : at com.android.server.SystemServer.startOtherServices(SystemServer.java:2811) 10-07 02:32:36.488 14748 14748 E System : at com.android.server.SystemServer.run(SystemServer.java:946) 10-07 02:32:36.488 14748 14748 E System : at com.android.server.SystemServer.main(SystemServer.java:668) 10-07 02:32:36.488 14748 14748 E System : at java.lang.reflect.Method.invoke(Native Method) 10-07 02:32:36.488 14748 14748 E System : at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552) 10-07 02:32:36.488 14748 14748 E System : at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:959) 10-07 02:32:36.488 14748 14748 V SystemServerTiming: MakePackageManagerServiceReady took to complete: 41ms --------- beginning of crash 10-07 02:32:36.489 14748 14748 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: main 10-07 02:32:36.489 14748 14748 E AndroidRuntime: java.lang.IllegalStateException: Signature|privileged permissions not in privapp-permissions allowlist: {com.android.car.carlauncher (/system/priv-app/CarLauncher.apk): android.permission.SET_WALLPAPER_COMPONENT} 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at com.android.server.pm.permission.PermissionManagerServiceImpl.onSystemReady(PermissionManagerServiceImpl.java:4447) 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at com.android.server.pm.permission.PermissionManagerService$PermissionManagerServiceInternalImpl.onSystemReady(PermissionManagerService.java:743) 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at com.android.server.pm.PackageManagerService.systemReady(PackageManagerService.java:4265) 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at com.android.server.SystemServer.startOtherServices(SystemServer.java:2811) 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at com.android.server.SystemServer.run(SystemServer.java:946) 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at com.android.server.SystemServer.main(SystemServer.java:668) 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at java.lang.reflect.Method.invoke(Native Method) 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552) 10-07 02:32:36.489 14748 14748 E AndroidRuntime: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:959) 10-07 02:32:36.490 14748 14748 I DropBoxManagerService: add tag=system_server_crash isTagEnabled=true flags=0x2 解决办法： 在/etc/permisions/下找到privapp-permissions-platform.xml或privapp-permissions-qti.xml，自行添加权限；\n","permalink":"http://localhost:1313/posts/%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99signature-privileged-permissions-not-in-privapp-permissions-allowlist/","summary":"运行报错：Signature Privileged Permissions Not in Privapp Permissions Allowlist","title":"运行报错：Signature Privileged Permissions Not in Privapp Permissions Allowlist"},{"content":"问题 本地编译SystemUI的时候，Android Studio报错\n![[Pasted image 20250320101838.png]]\nDuplicate class kotlin.collections.jdk8.CollectionsJDK8Kt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.internal.jdk7.JDK7PlatformImplementations found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.internal.jdk8.JDK8PlatformImplementations found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.io.path.ExperimentalPathApi found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.io.path.PathRelativizer found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.io.path.PathsKt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.io.path.PathsKt__PathReadWriteKt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.io.path.PathsKt__PathUtilsKt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.jdk7.AutoCloseableKt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk7-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.6.0) Duplicate class kotlin.jvm.jdk8.JvmRepeatableKt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.random.jdk8.PlatformThreadLocalRandom found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt$asSequence$$inlined$Sequence$1 found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt$asSequence$$inlined$Sequence$2 found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt$asSequence$$inlined$Sequence$3 found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.streams.jdk8.StreamsKt$asSequence$$inlined$Sequence$4 found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.text.jdk8.RegexExtensionsJDK8Kt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) Duplicate class kotlin.time.jdk8.DurationConversionsJDK8Kt found in modules kotlin-stdlib-1.8.22 (org.jetbrains.kotlin:kotlin-stdlib:1.8.22) and kotlin-stdlib-jdk8-1.6.0 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.0) 解决办法： build.gradle添加\nimplementation(platform(\u0026#34;org.jetbrains.kotlin:kotlin-bom:1.8.10\u0026#34;)) ","permalink":"http://localhost:1313/posts/kotlin%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E6%8A%A5%E9%94%99-duplicate-class/","summary":"Kotlin版本冲突报错 Duplicate Class","title":"Kotlin版本冲突报错 Duplicate Class"},{"content":"\nIn file included from hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_soa/include/CommunicationSOAImpl.h:3: In file included from hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_base/include/IVehicleCommunication.h:3: In file included from hardware/interfaces/automotive/vehicle/aidl/impl/utils/common/include/VehicleHalTypes.h:20: In file included from out/soong/.intermediates/hardware/interfaces/automotive/vehicle/aidl_property/android.hardware.automotive.vehicle.property-V2-ndk-source/gen/include/aidl/android/hardware/automotive/vehicle/AutomaticEmergencyBrakingState.h:3: In file included from external/libcxx/include/array:112: In file included from external/libcxx/include/algorithm:644: external/libcxx/include/memory:4972:16: error: use of dynamic_cast requires -frtti _Tp* __p = dynamic_cast\u0026lt;_Tp*\u0026gt;(__r.get()); ^ hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_soa/src-gen/v2/commonapi/CanInfoServiceProxy.hpp:113:24: note: in instantiation of function template specialization \u0026#39;std::dynamic_pointer_cast\u0026lt;v2::commonapi::CanInfoServiceProxyBase, CommonAPI::Proxy\u0026gt;\u0026#39; requested here delegate_(std::dynamic_pointer_cast\u0026lt; CanInfoServiceProxyBase\u0026gt;(delegate)) { ^ external/libcxx/include/memory:2156:9: note: in instantiation of member function \u0026#39;v2::commonapi::CanInfoServiceProxy\u0026lt;\u0026gt;::CanInfoServiceProxy\u0026#39; requested here : __value_(_VSTD::forward\u0026lt;_Args\u0026gt;(_VSTD::get\u0026lt;_Indexes\u0026gt;(__args))...) {} ^ external/libcxx/include/memory:4331:26: note: in instantiation of function template specialization \u0026#39;std::__shared_ptr_emplace\u0026lt;v2::commonapi::CanInfoServiceProxy\u0026lt;\u0026gt;, std::allocator\u0026lt;v2::commonapi::CanInfoServiceProxy\u0026lt;\u0026gt;\u0026gt;\u0026gt;::__shared_ptr_emplace\u0026lt;std::shared_ptr\u0026lt;CommonAPI::Proxy\u0026gt; \u0026amp;\u0026gt;\u0026#39; requested here ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward\u0026lt;_Args\u0026gt;(__args)...); ^ external/libcxx/include/memory:4710:29: note: in instantiation of function template specialization \u0026#39;std::shared_ptr\u0026lt;v2::commonapi::CanInfoServiceProxy\u0026lt;\u0026gt;\u0026gt;::make_shared\u0026lt;std::shared_ptr\u0026lt;CommonAPI::Proxy\u0026gt; \u0026amp;\u0026gt;\u0026#39; requested here return shared_ptr\u0026lt;_Tp\u0026gt;::make_shared(_VSTD::forward\u0026lt;_Args\u0026gt;(__args)...); ^ external/capicxx-core-runtime/include/CommonAPI/Runtime.hpp:56:25: note: in instantiation of function template specialization \u0026#39;std::__1::make_shared\u0026lt;v2::commonapi::CanInfoServiceProxy\u0026lt;\u0026gt;, std::shared_ptr\u0026lt;CommonAPI::Proxy\u0026gt; \u0026amp;\u0026gt;\u0026#39; requested here return std::make_shared\u0026lt;ProxyClass_\u0026lt;AttributeExtensions_...\u0026gt;\u0026gt;(proxy); ^ hardware/interfaces/automotive/vehicle/aidl/impl/maxj/communication/comm_soa/src/CommunicationSOAImpl.cpp:39:36: note: in instantiation of function template specialization \u0026#39;CommonAPI::Runtime::buildProxy\u0026lt;v2::commonapi::CanInfoServiceProxy\u0026gt;\u0026#39; requested here canInfoServiceProxy = runtime-\u0026gt;buildProxy\u0026lt;v2::commonapi::CanInfoServiceProxy\u0026gt;(\u0026#34;local\u0026#34;, \u0026#34;CanInfoService\u0026#34;, \u0026#34;default\u0026#34;); ^ 1 error generated. 19:08:25 ninja failed with: exit status 1 #### failed to build some targets (12 seconds) #### Solution bp文件添加\nrtti:true, RTTI（Run-Time Type Information，运行时类型信息）是 C++ 中的一种机制，允许程序在运行时获取对象的类型信息。通过 RTTI，程序可以在运行时检查和操作对象的类型，而不仅仅是在编译时进行类型检查。\n","permalink":"http://localhost:1313/posts/error-use-of-dynamic_cast-requires--frtti/","summary":"error use of dynamic_cast requires -frtti","title":"error use of dynamic_cast requires -frtti"},{"content":"现象 CarLauncher移植到Android Studio后，App列表页面显示不正常，图标偏小，布局偏移； 正常的现象（源码编译出来的CarLauncher）\n不正常的现象（Android Studio编译）\n解决思路 没有怎么解决过布局的问题，一开始还是有点头脑空白，但是既然是尺寸问题，那就用工具查看尺寸吧\n使用Android Studio的Layout Inspector， 查看和记录正常、异常的尺寸， 既然很多尺寸都对不上，找几个有差别的尺寸持续分析就好。我这里记录了图标大小的尺寸，正常大小是76dp，异常大小是18dp；\n查看Launcher源码，找到CarLauncher的item图标尺寸大小，验证76dp和18dp是从哪里来的；\nImageView的尺寸是app_grid_touch_target_size \u0026ndash;\u0026gt; 引用@*android:dimen/car_touch_target_size \u0026ndash;\u0026gt; car_touch_target_size，最终尺寸是76dp，这个应该是正常的；那么异常的18dp是否被overlay覆盖或者其他途径修改等情况呢？简单搜索并没有发现，但是无论如何，最终肯定都会编译进apk，我们反编译一下apk试一下；\n反编译正常的apk和异常的apk，查看同样的尺寸，发现app_grid_touch_target_size最终编译成了另外的尺寸，但是很明显源码编译的和AS编译的内容不同；\n正常的apk： \u0026lt;dimen name=\u0026#34;app_grid_touch_target_size\u0026#34;\u0026gt;@android:dimen/chooser_header_scroll_elevation\u0026lt;/dimen\u0026gt; 异常的apk： \u0026lt;dimen name=\u0026#34;app_grid_touch_target_size\u0026#34;\u0026gt;@android:dimen/chooser_preview_image_border\u0026lt;/dimen\u0026gt; 进一步搜索chooser_preview_image_border，发现这个尺寸为1dp，而且看名称，像是个边界线的宽度尺寸；\n在这里，需要停下来思考一下，为什么源码编译和AS编译不同，如果问题不出现在源码上，又出现在哪里？\nAndroid在编译apk的时候，很多时候会进行序列化在链接各个文件等等，这里可能是从这个方向出发。\n一般编译时候进行序列化，导致最终链接的位置不一样，这种情况一般是因为使用的依赖、工具等有所差异，而这些东西不在自己源码控制范围内，但最终都会编译进入apk；结合上面SDK为33，其实我们的CarLauncher是在Android12 SDK 32版本基础上挪动的，是否是这个原因导致的呢？\n源码查找当前源码的SDK版本cat build/core/version_defaults.mk | grep SDK -i，确认当前SDK版本是32；\nbuild.gradle修改compileSdk为 32， 验证问题；\nDone；\n经验和教训 有空还是得研究一下Android源码编译、AS编译、命令行打包apk等原理和流程； 在移植源码到本地编译的时候，需要注意各个依赖的版本，包括本地的SDK； 在平时Debug的时候，为什么会觉得难？理由是不注重细节和想当然。如果没有确认这个资源文件的位置，我可能理所当然认为这个资源在framework-res了，如果不注重细节去仔细推测观察chooser_preview_image_border的名称和作用，我也不会联想到这个应该是个边界线，进而推测到不是源码本身的错误。上述第4、5步，其实没有很规范的debug推测流程，算是一种直觉，是经验的积累，也是细节的推敲。 ","permalink":"http://localhost:1313/posts/carlauncher%E6%98%BE%E7%A4%BA%E5%B0%BA%E5%AF%B8%E4%B8%8D%E6%AD%A3%E5%B8%B8/","summary":"CarLauncher显示尺寸不正常","title":"CarLauncher显示尺寸不正常"},{"content":"Step Anaylyze the dependencies and draw a dependencies tree;\n分析模块依赖，并画出依赖结构； Import or new Modules from the smallest unit;\n从最小模块（没有依赖或者尽可能少依赖的）导入； Make sure every modules could be build and run correctly;\n保证每个模块都能正确编译和运行； Continue import next smallest unit;\n继续导入下一个最小模块； Dependencies Analysis CarLauncher \\----- CarLauncher-core |---- androidx-constraintlayout_constraintlayout-solver |---- androidx-constraintlayout_constraintlayout |---- androidx.lifecycle_lifecycle-extensions |---- car-media-common |---- androidx.cardview_cardview |---- androidx.legacy_legacy-support-v4 |---- androidx.recyclerview_recyclerview |---- androidx.mediarouter_mediarouter |---- androidx-constraintlayout_constraintlayout |---- car-apps-common |---- androidx.annotation_annotation |---- androidx.cardview_cardview |---- androidx.interpolator_interpolator |---- androidx.lifecycle_lifecycle-common-java8 |---- androidx.lifecycle_lifecycle-extensions |---- androidx-constraintlayout_constraintlayout |---- androidx.recyclerview_recyclerview |---- androidx-constraintlayout_constraintlayout-solver |---- car-ui-lib \\---- junit \\---- androidx-constraintlayout_constraintlayout-solver |---- car-telephony-common |---- androidx.legacy_legacy-support-v4 |---- car-apps-common |---- glide-prebuilt |---- guava |---- libphonenumber |---- car-ui-lib |---- com.google.android.material_material |---- WindowManager-Shell |---- launcher_item |---- SystemUISharedLib \\---- android.car ","permalink":"http://localhost:1313/posts/carlauncher%E5%AF%BC%E5%85%A5%E5%88%B0androidstudio%E6%96%B9%E6%B3%95/","summary":"CarLauncher导入到AndroidStudio方法","title":"CarLauncher导入到AndroidStudio方法"},{"content":"Date：2025-03-07\n问题背景 packages/module/Bluetooth/下的修改会被覆盖，每次编译这里都会产生变化； 排查过程 逐步根据编译脚本进行排查， source build/envsetup.sh \u0026ndash;\u0026gt; lunch \u0026ndash;\u0026gt; 8775脚本等； 每步命令之后都git status查看路径下是否产生变化； 已经确定是lunch的问题；\n查看lunch源码，源码在build/envsetup.sh中，lunch方法会调用build_build_var_cache；\nbuild_build_var_cache最终调用soongui，而且是\u0026ndash;dumpvars-mode模式；\nfunction build_build_var_cache() { local T=$(gettop) # Grep out the variable names from the script. cached_vars=(`cat $T/build/envsetup.sh | tr \u0026#39;()\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{for(i=1;i\u0026lt;=NF;i++) if($i~/get_build_var/) print $(i+1)}\u0026#39; | sort -u | tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39;`) cached_abs_vars=(`cat $T/build/envsetup.sh | tr \u0026#39;()\u0026#39; \u0026#39; \u0026#39; | awk \u0026#39;{for(i=1;i\u0026lt;=NF;i++) if($i~/get_abs_build_var/) print $(i+1)}\u0026#39; | sort -u | tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39;`) # Call the build system to dump the \u0026#34;\u0026lt;val\u0026gt;=\u0026lt;value\u0026gt;\u0026#34; pairs as a shell script. build_dicts_script=`\\builtin cd $T; build/soong/soong_ui.bash --dumpvars-mode \\ --vars=\u0026#34;${cached_vars[*]}\u0026#34; \\ --abs-vars=\u0026#34;${cached_abs_vars[*]}\u0026#34; \\ --var-prefix=var_cache_ \\ --abs-var-prefix=abs_var_cache_` local ret=$? if [ $ret -ne 0 ] then unset build_dicts_script return $ret fi # Execute the script to store the \u0026#34;\u0026lt;val\u0026gt;=\u0026lt;value\u0026gt;\u0026#34; pairs as shell variables. eval \u0026#34;$build_dicts_script\u0026#34; ret=$? unset build_dicts_script if [ $ret -ne 0 ] then return $ret fi BUILD_VAR_CACHE_READY=\u0026#34;true\u0026#34; } soong里面这里有点弯绕，看不下去，但是记得好像有日志开关，查看有没有日志或者日志开关在哪里；\nout目录下，查找soong的日志，从修改时间上大概可以猜出确定这几份； 拉下日志查找蓝牙日志 这里已经很明晰，调用的链路和脚本；\n阅读qva_bt.sh\n需要执行的代码清单在qva_bt_source.txt里面； 如果是Android.bp，会在源路径加后缀.disable \u0026ndash;\u0026gt; 不存在 \u0026ndash;\u0026gt; 不复制； 复制时判断路径指定的代码与目标路径的代码是否相同 \u0026ndash;\u0026gt; 不同就复制过去； ","permalink":"http://localhost:1313/posts/android-module-bluetooth%E8%A2%AB%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/","summary":"Android Module Bluetooth被覆盖问题排查","title":"Android Module Bluetooth被覆盖问题排查"},{"content":"Android9超过2G升级包无法升级问题排查与解决方案 问题描述 问题表象 Android9系统，当升级包大小超过2G的时候，升级失败。\nupdate_engine报错 04-27 11:09:50.511 2293 2293 E update_engine:[0427/110950.511596:ERROR:payload_metadata.cc(74)] Bad payload format -- invalid delta magic. 04-27 11:09:50.511 2293 2293 E update_engine:[0427/110950.511679:ERROR:download_action.cc(337)] Error ErrorCode::kDownloadInvalidMetadataMagicString (21) in DeltaPerformet\u0026#39;s Write method when processing the received payload -- Terminating processing 原因分析 通过日志可以看出update_engine报错错误码kDownloadInvalidMetadataMagicString（21），通过查阅update_engine源码得知，在update_engine中是因为解析出来的payload.bin前面的元数据不是\u0026rsquo;CrAU\u0026rsquo;（Android源码定义的就是CrAU）导致；\n升级包偏移量 通过参考资料得知：\n.zip文件的文件格式中，会在生成一定的头部信息，然后内部的文件会按一定规则顺序排列在后面； 压缩包内容中，头部有30个字节是固定的，然后后面就到文件名（可变长度）、拓展区（可变长度），这些加起来就是头部内容的长度。 参考： Android A/B System OTA分析（六）如何获取 payload 的 offset 和 size_packageoffset size_洛奇看世界的博客-CSDN博客\nmetadata数据中的偏移量与升级包实际的偏移量对不上，这个偏移量其实指的是压缩包内文件数据(payload.bin)在文件（升级包）中的偏移量。系统打包的时候会将这个偏移量解析出来写在metadata中，而update_engine会根据metadata文件中定义的这个偏移量提取payload.bin，并判断payload.bin的前4个字节是不是\u0026rsquo;CrAU\u0026rsquo;，如果提取出来的payload.bin的前4个字节与\u0026rsquo;CrAU\u0026rsquo;不匹配，则证明偏移量错误，导致提取的payload.bin文件不正确；\n既然得知这原理，后面主要是看针对一个问题：\n一个问题：为什么metadata中的偏移量和实际压缩包的偏移量对应不上？ \u0026ndash;\u0026gt; metadata的偏移量是如何生成的？\nmetadata的偏移量是如何生成？ 从打包的python脚本ota_from_target_files.py入手，具体的排查过程不赘述。\n最终排查到这个偏移量的计算有两处：其中一处是用于解析偏移量，一处是用来做重新计算校验的（因为解析之后经过了一些签名之类的处理，所以重新校验）。这里能校验过，是因为解析和校验用的接口和公式是一致的。\npayload_offset = payload_info.header_offset + len(payload_info.FileHeader()) // 计算 offset = info.header_ofet + len(info.FileHeader()) // 生成 通过在python脚本添加打印得知， 升级包无论大于或小于2G：\npayload_info.header_offset、 info.header_ofet均不变，len(payload_info.FileHeader())、len(info.FileHeader())均改变了； payload_info.header_offset和info.header_ofet是文件在压缩包本身的偏移量（例如如果文件在压缩包排在第2个，它本身的偏移量就要加上第一个文件占用的部分）； len(payload_info.FileHeader())、len(info.FileHeader())是压缩包内此文件的头部。这两部分偏移量加起来， 才是这文件在压缩包中要提取的数据； 制作一个超过2G的升级包，并通过imhex工具查看升级包、zipinfo命令查看压缩包信息，均发现payload.bin在压缩包的偏移量为47，但是通过python打印出来的是67。\n因此继续查阅python代码，最终发现fileHeader的extra拓展区部分在大于2G的时候，额外计算多了一部分信息。下面代码会对升级包进行判断，若文件大小或者压缩包大小大于ZIP64_LIMIT大小，则认为是zip64；若属于zip64，会在extra拓展区部分额外增加了一部分数据。通过打印复现，把这部分数据减掉，刚好是实际压缩包的47。\nif zip64 is None: zip64 = file_size \u0026gt; ZIP64_LIMIT or compress_size \u0026gt; ZIP64_LIMIT # 这里的ZIP64_LIMIT是2G if zip64: fmt = \u0026#39;\u0026lt;HHQQ\u0026#39; extra = extra + struct.pack(fmt, 1, struct.calcsize(fmt)-4, file_size, compress_size) 这里便是metadata中偏移量的计算，那么在打包时，payload.bin又是如何打进zip的呢？\npayload.bin的实际偏移量由来？ 从打包的python脚本ota_from_target_files.py入手，具体的排查过程不赘述。最终排查到common.py的ZipWrite方法。\n通过注释的意思和代码，可以得知，Android为了能够编译出2G以上的包，将zipFile的ZIP64_LIMIT改为了4G，这个ZIP64_LIMIT就上面用来判断是否为zip64的一个条件。\nzip_file.write在python中同样用到了FileHeader()方法，但是写入的时候因为小于4G，不认为是zip64，所以extra另外的那一部分数据没有写入，但是在解析的时候却认为是zip64，导致写入和解析所获取的长度不一致。update_engine根据metadata的偏移量解析出来的payload.bin自然就不正确了。\n总结：脚本在写入升级包是，认为文件\u0026lt;4G，使用zip32格式写入，解析升级包时认为文件\u0026gt;2G，按照zip64格式解析计算偏移量，最终导致metadata中的偏移量偏大。\ndef ZipWrite(zip_file, filename, arcname=None, perms=0o644, compress_type=None): import datetime # http://b/18015246 # Python 2.7\u0026#39;s zipfile implementation wrongly thinks that zip64 is required # for files larger than 2GiB. We can work around this by adjusting their # limit. Note that `zipfile.writestr()` will not work for strings larger than # 2GiB. The Python interpreter sometimes rejects strings that large (though # it isn\u0026#39;t clear to me exactly what circumstances cause this). # `zipfile.write()` must be used directly to work around this. # # This mess can be avoided if we port to python3. saved_zip64_limit = zipfile.ZIP64_LIMIT zipfile.ZIP64_LIMIT = (1 \u0026lt;\u0026lt; 32) - 1 if compress_type is None: compress_type = zip_file.compression if arcname is None: arcname = filename saved_stat = os.stat(filename) try: # `zipfile.write()` doesn\u0026#39;t allow us to pass ZipInfo, so just modify the # file to be zipped and reset it when we\u0026#39;re done. os.chmod(filename, perms) # Use a fixed timestamp so the output is repeatable. epoch = datetime.datetime.fromtimestamp(0) timestamp = (datetime.datetime(2009, 1, 1) - epoch).total_seconds() os.utime(filename, (timestamp, timestamp)) zip_file.write(filename, arcname=arcname, compress_type=compress_type) finally: os.chmod(filename, saved_stat.st_mode) os.utime(filename, (saved_stat.st_atime, saved_stat.st_mtime)) zipfile.ZIP64_LIMIT = saved_zip64_limit 解决方法 方法1： 既然知道是因为python的FileHeader()会在文件头部的拓展区部分额外增加了导致的，那可以直接根据zip压缩包的结构，将公式改为\noffset = info.header_offset + info.filename.__len__() + info.extra.__len__() + 30 # 可以参考上面提供的链接文章， 30这里是头部的固定长度， 但是尽量推荐下面官方的解决办法 方法2（推荐解决方法）： 根据AOSP官方代码库的修改记录，移植相关方法。\nCommit:25ab998 Fix a bug in computing streaming property of payload.bin When computing the data offset of an entry in zip file, we used length of extra field from central directory. That is correct most of the time but wrong if the extra field in central directory has different length than the one in local file directory. Since python\u0026rsquo;s zipfile doesn\u0026rsquo;t provide an API to access local file header, we need to parse local file header ourselves and extract length of extra field. An incorrect offset will cause magic mismatch error from update_engine, as update_engine expects to find uncompressed payload at the recorded offset. Test: th, partner verification Bug: 191443484 Change-Id: Id670cd79b0bd65adffaaa5224ae4f8065d66b358、 zhangkelvin@google.com(author) eventCommitted on2021-07-28 11:40 PM\n因为本地代码和2021-07的代码还是存在较大差异。仅移植需要用到的部分。\nota_from_target_files.py方法增加以下改动（megre部分）\n# ************** merge start ************* # https://cs.android.com/android/_/android/platform/build/+/928c2341a6abc3b1ddb7ddd7652e78b67c7ef7a9 def GetZipEntryOffset(zfp, entry_info): \u0026#34;\u0026#34;\u0026#34;Get offset to a beginning of a particular zip entry Args: fp: zipfile.ZipFile entry_info: zipfile.ZipInfo Returns: (offset, size) tuple \u0026#34;\u0026#34;\u0026#34; # Don\u0026#39;t use len(entry_info.extra). Because that returns size of extra # fields in central directory. We need to look at local file directory, # as these two might have different sizes. # We cannot work with zipfile.ZipFile instances, we need a |fp| for the underlying file. zfp = zfp.fp zfp.seek(entry_info.header_offset) data = zfp.read(zipfile.sizeFileHeader) fheader = struct.unpack(zipfile.structFileHeader, data) # Last two fields of local file header are filename length and # extra length filename_len = fheader[-2] extra_len = fheader[-1] offset = entry_info.header_offset offset += zipfile.sizeFileHeader offset += filename_len + extra_len size = entry_info.file_size return (offset, size) # ************** merge end ************* def ComputeEntryOffsetSize(name): \u0026#34;\u0026#34;\u0026#34;Computes the zip entry offset and size.\u0026#34;\u0026#34;\u0026#34; info = zip_file.getinfo(name) # offset = info.header_offset + len(info.FileHeader()) # ************** merge start ************* # merge 928c234 Allow zip64 support when opening zip files start # https://cs.android.com/android/_/android/platform/build/+/928c2341a6abc3b1ddb7ddd7652e78b67c7ef7a9 (offset, size) = GetZipEntryOffset(zip_file, info) # offset = info.header_offset + info.filename.__len__() + info.extra.__len__() + 30 # size = info.file_size # ************** merge end ************* return \u0026#39;%s:%d:%d\u0026#39; % (os.path.basename(name), offset, size) payload_info = input_zip.getinfo(\u0026#39;payload.bin\u0026#39;) # ************** merge start ************* # ---- by Y4944 2023/07/21 # https://cs.android.com/android/_/android/platform/build/+/928c2341a6abc3b1ddb7ddd7652e78b67c7ef7a9 # payload_offset = payload_info.header_offset + len(payload_info.FileHeader()) (payload_offset, payload_size) = GetZipEntryOffset(input_zip, payload_info) # payload_offset = payload_info.header_offset + payload_info.filename.__len__() + payload_info.extra.__len__() + 30 # payload_size = payload_info.file_size # ************** merge end ************* with input_zip.open(\u0026#39;payload.bin\u0026#39;, \u0026#39;r\u0026#39;) as payload_fp: header_bin = payload_fp.read(24) # network byte order (big-endian) header = struct.unpack(\u0026#34;!IQQL\u0026#34;, header_bin) # \u0026#39;CrAU\u0026#39; magic = header[0] assert magic == 0x43724155, \u0026#34;Invalid magic: {:x}\u0026#34;.format(magic) manifest_size = header[2] metadata_signature_size = header[3] metadata_total = 24 + manifest_size + metadata_signature_size assert metadata_total \u0026lt; payload_size return (payload_offset, metadata_total) ","permalink":"http://localhost:1313/posts/android9%E8%B6%85%E8%BF%872g%E5%8D%87%E7%BA%A7%E5%8C%85%E6%97%A0%E6%B3%95%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","summary":"Android9超过2G升级包无法升级问题排查与解决方案","title":"Android9超过2G升级包无法升级问题排查与解决方案"},{"content":"基本知识 Android编译一般输入如下命令进行选择全编 source build/envsetup.sh lunch \u0026lt;combo\u0026gt; m -j 16 单编 mm、mma、mmm、mmma 脚本篇 source envsetup.sh 源码解析 编译的第一步是运行source build/envsetup.sh，逐步看下发生了什么。\n# ... T=$(_gettop_once) if [ ! \u0026#34;$T\u0026#34; ]; then echo \u0026#34;Couldn\u0026#39;t locate the top of the tree. Always source build/envsetup.sh from the root of the tree.\u0026#34; \u0026gt;\u0026amp;2 return 1 fi IMPORTING_ENVSETUP=true source $T/build/make/shell_utils.sh # ... validate_current_shell set_global_paths source_vendorsetup addcompletions 获取TOP 进入之后立马获取一次TOP，就是Android根目录； 如果获取不到TOP，就输出提示，重定向到stderr； 导入shell_utils.sh 设置IMPORTING_ENVSETUP为true； 导入shell_utils.sh； validate_current_shell 检测当前shell是否为bash或者zsh，bash是linux的shell，zsh是macOS的shell；都不是，提示警告；可以近似认为：只有Linux（bash shell）或者macOS（zsh shell）才可以编译AOSP； function validate_current_shell() { local current_sh=\u0026#34;$(ps -o command -p $$)\u0026#34; case \u0026#34;$current_sh\u0026#34; in *bash*) function check_type() { type -t \u0026#34;$1\u0026#34;; } ;; *zsh*) function check_type() { type \u0026#34;$1\u0026#34;; } enable_zsh_completion ;; *) echo -e \u0026#34;WARNING: Only bash and zsh are supported.\\nUse of other shell would lead to erroneous results.\u0026#34; ;; esac} set_global_paths 设置环境变量，这些环境变量包括build/soong/bin、build/bazel/bin、development/scripts、prebuilts/devtools/tools等； 如果prebuilts/android-emulator// 存在，就设置环境变量； # Add directories to PATH that are NOT dependent on the lunch target. # For directories that are lunch-specific, add them in set_lunch_paths function set_global_paths() { local T=$(gettop) if [ ! \u0026#34;$T\u0026#34; ]; then echo \u0026#34;Couldn\u0026#39;t locate the top of the tree. Try setting TOP.\u0026#34; return fi ################################################################## # # # Read me before you modify this code # # # # This function sets ANDROID_GLOBAL_BUILD_PATHS to what it is # # adding to PATH, and the next time it is run, it removes that # # from PATH. This is required so envsetup.sh can be sourced # # more than once and still have working paths. # # # ################################################################## # Out with the old... if [ -n \u0026#34;$ANDROID_GLOBAL_BUILD_PATHS\u0026#34; ] ; then export PATH=${PATH/$ANDROID_GLOBAL_BUILD_PATHS/} fi # And in with the new... ANDROID_GLOBAL_BUILD_PATHS=$T/build/soong/bin ANDROID_GLOBAL_BUILD_PATHS+=:$T/build/bazel/bin ANDROID_GLOBAL_BUILD_PATHS+=:$T/development/scripts ANDROID_GLOBAL_BUILD_PATHS+=:$T/prebuilts/devtools/tools # add kernel specific binaries if [ $(uname -s) = Linux ] ; then ANDROID_GLOBAL_BUILD_PATHS+=:$T/prebuilts/misc/linux-x86/dtc ANDROID_GLOBAL_BUILD_PATHS+=:$T/prebuilts/misc/linux-x86/libufdt fi # If prebuilts/android-emulator/\u0026lt;system\u0026gt;/ exists, prepend it to our PATH # to ensure that the corresponding \u0026#39;emulator\u0026#39; binaries are used. case $(uname -s) in Darwin) ANDROID_EMULATOR_PREBUILTS=$T/prebuilts/android-emulator/darwin-x86_64 ;; Linux) ANDROID_EMULATOR_PREBUILTS=$T/prebuilts/android-emulator/linux-x86_64 ;; *) ANDROID_EMULATOR_PREBUILTS= ;; esac if [ -n \u0026#34;$ANDROID_EMULATOR_PREBUILTS\u0026#34; -a -d \u0026#34;$ANDROID_EMULATOR_PREBUILTS\u0026#34; ]; then ANDROID_GLOBAL_BUILD_PATHS+=:$ANDROID_EMULATOR_PREBUILTS export ANDROID_EMULATOR_PREBUILTS fi # Finally, set PATH export PATH=$ANDROID_GLOBAL_BUILD_PATHS:$PATH } source_vendorsetup 如果发现1个allowed-vendorsetup_sh-files 文件存在，就加载 allowed-vendorsetup_sh-files 文件限定的 vendorsetup.sh 文件; 如果发现多个allowed-vendorsetup_sh-files 文件存在，则会报错并停止加载； 如果发现allowed-vendorsetup_sh-files 文件不存在， 加载指定目录下的 vendorsetup.sh 文件; # Execute the contents of any vendorsetup.sh files we can find. # Unless we find an allowed-vendorsetup_sh-files file, in which case we\u0026#39;ll only # load those. # # This allows loading only approved vendorsetup.sh files function source_vendorsetup() { unset VENDOR_PYTHONPATH local T=\u0026#34;$(gettop)\u0026#34; allowed= for f in $(cd \u0026#34;$T\u0026#34; \u0026amp;\u0026amp; find -L device vendor product -maxdepth 4 -name \u0026#39;allowed-vendorsetup_sh-files\u0026#39; 2\u0026gt;/dev/null | sort); do if [ -n \u0026#34;$allowed\u0026#34; ]; then echo \u0026#34;More than one \u0026#39;allowed_vendorsetup_sh-files\u0026#39; file found, not including any vendorsetup.sh files:\u0026#34; echo \u0026#34; $allowed\u0026#34; echo \u0026#34; $f\u0026#34; return fi allowed=\u0026#34;$T/$f\u0026#34; done allowed_files= [ -n \u0026#34;$allowed\u0026#34; ] \u0026amp;\u0026amp; allowed_files=$(cat \u0026#34;$allowed\u0026#34;) for dir in device vendor product; do for f in $(cd \u0026#34;$T\u0026#34; \u0026amp;\u0026amp; test -d $dir \u0026amp;\u0026amp; \\ find -L $dir -maxdepth 4 -name \u0026#39;vendorsetup.sh\u0026#39; 2\u0026gt;/dev/null | sort); do if [[ -z \u0026#34;$allowed\u0026#34; || \u0026#34;$allowed_files\u0026#34; =~ $f ]]; then echo \u0026#34;including $f\u0026#34;; . \u0026#34;$T/$f\u0026#34; else echo \u0026#34;ignoring $f, not in $allowed\u0026#34; fi done done setup_cog_env_if_needed } addcompletions 设置补全文件，用于做补全命令使用。（就是能不能tab出来）； function addcompletions() { local f= # Keep us from trying to run in something that\u0026#39;s neither bash nor zsh. if [ -z \u0026#34;$BASH_VERSION\u0026#34; -a -z \u0026#34;$ZSH_VERSION\u0026#34; ]; then return fi # Keep us from trying to run in bash that\u0026#39;s too old. if [ -n \u0026#34;$BASH_VERSION\u0026#34; -a ${BASH_VERSINFO[0]} -lt 3 ]; then return fi local completion_files=( packages/modules/adb/adb.bash system/core/fastboot/fastboot.bash tools/asuite/asuite.sh ) # Completion can be disabled selectively to allow users to use non-standard completion. # e.g. # ENVSETUP_NO_COMPLETION=adb # -\u0026gt; disable adb completion # ENVSETUP_NO_COMPLETION=adb:bit # -\u0026gt; disable adb and bit completion local T=$(gettop) for f in ${completion_files[*]}; do f=\u0026#34;$T/$f\u0026#34; if [ ! -f \u0026#34;$f\u0026#34; ]; then echo \u0026#34;Warning: completion file $f not found\u0026#34; elif should_add_completion \u0026#34;$f\u0026#34;; then . $f fi done if [ -z \u0026#34;$ZSH_VERSION\u0026#34; ]; then # Doesn\u0026#39;t work in zsh. complete -o nospace -F _croot croot # TODO(b/244559459): Support b autocompletion for zsh complete -F _bazel__complete -o nospace b fi complete -F _lunch lunch complete -F _lunch_completion lunch2 complete -F _complete_android_module_names pathmod complete -F _complete_android_module_names gomod complete -F _complete_android_module_names outmod complete -F _complete_android_module_names installmod complete -F _complete_android_module_names m } 其他命令 其实 source 某个脚本后， 脚本内的函数是可以直接调用的；例如附录下的命令，有许多都是定义在 envsetup.sh 脚本中的；\n在Android14及以前，这些大部分命令都是在 envsetup.sh 脚本中， Android15开始，将这些命令挪到了build/soong/bin中；\n总结 获取一次根目录； 导入shell_utils.sh； 校验shell -\u0026gt; 设置全局环境变量 -\u0026gt; 查找加载供应商vendorsetup.sh脚本 -\u0026gt; 完成命令补全操作； 提供其他便捷命令； unset了一些命令，这些命令一开始写在envsetup.sh的脚本，后来都放在soong系统里面了，因此需要unset； 附录：脚本的命令 方法名 功能描述 _gettop_once 查找并返回项目的根目录路径。 hmm 显示帮助信息，列出所有可用的函数及其用途。 build_build_var_cache 缓存构建变量，以便快速获取构建系统中的变量值。 destroy_build_var_cache 清除构建变量缓存。 get_abs_build_var 获取构建变量的绝对路径值。 get_build_var 获取构建变量的精确值。 check_product 检查指定的产品是否可以构建。 check_variant 检查指定的变体是否有效。 set_lunch_paths 设置与lunch目标相关的环境路径。 set_global_paths 设置与全局环境相关的路径。 printconfig 打印当前构建配置信息。 set_stuff_for_environment 设置构建环境所需的基本变量和路径。 set_sequence_number 设置构建环境的序列号。 should_add_completion 检查是否应为某个命令添加补全功能。 addcompletions 添加命令补全功能（支持bash和zsh）。 multitree_lunch_help 显示multitree_lunch的帮助信息。 multitree_lunch 配置多树构建环境，设置产品和变体组合。 choosetype 选择构建类型（release或debug）。 chooseproduct 选择要构建的产品。 choosevariant 选择构建变体（如eng、userdebug等）。 choosecombo 综合选择构建类型、产品和变体。 add_lunch_combo （已废弃）添加新的lunch组合选项。 print_lunch_menu 打印常见的lunch组合菜单。 lunch 配置构建环境，选择产品和变体组合。 tapas 配置构建环境以构建独立的应用程序（APK）。 banchan 配置构建环境以构建独立的模块（APEX）。 croot 切换到项目根目录或其子目录。 m 从项目根目录开始构建。 mm 构建当前目录下的模块及其依赖项。 mmm 构建指定目录下的模块及其依赖项。 mma 同mm，但会强制重新构建。 mmma 同mmm，但会强制重新构建。 provision 使用fastboot刷入设备所需的分区镜像。 cgrep 在本地C/C++文件中进行搜索。 ggrep 在本地Gradle文件中进行搜索。 gogrep 在本地Go文件中进行搜索。 jgrep 在本地Java文件中进行搜索。 jsongrep 在本地JSON文件中进行搜索。 ktgrep 在本地Kotlin文件中进行搜索。 resgrep 在本地资源文件（.xml）中进行搜索。 mangrep 在本地AndroidManifest.xml文件中进行搜索。 mgrep 在本地Makefile和.bp文件中进行搜索。 owngrep 在本地OWNERS文件中进行搜索。 rsgrep 在本地Rust文件中进行搜索。 sepgrep 在本地sepolicy文件中进行搜索。 sgrep 在本地源代码文件中进行搜索。 tomlgrep 在本地Toml文件中进行搜索。 pygrep 在本地Python文件中进行搜索。 godir 跳转到包含指定文件的目录。 allmod 列出所有模块。 gomod 跳转到指定模块所在的目录。 bmod 获取Soong模块的Bazel标签（如果已转换）。 pathmod 获取指定模块所在的目录。 outmod 获取指定模块安装输出的位置（带特定扩展名）。 dirmods 获取指定目录中定义的模块列表。 installmod 使用adb安装指定模块的APK。 refreshmod 刷新模块列表以供allmod、gomod、pathmod、outmod、installmod使用。 syswrite 将分区（如system.img）挂载为可写，并在必要时重启设备。 ======= lunch命令 源码解析\nlunch命令的源码还是在envsetup.sh脚本中 function lunch() { # 如果只有1个参数并且参数为--help，显示帮助 if [[ $# -eq 1 \u0026amp;\u0026amp; $1 = \u0026#34;--help\u0026#34; ]]; then _lunch_usage return 0 fi # 没有参数或者参数大于3个，提示并返回 if [[ $# -eq 0 ]]; then echo \u0026#34;No target specified. See lunch --help\u0026#34; 1\u0026gt;\u0026amp;2 return 1 fi if [[ $# -gt 3 ]]; then echo \u0026#34;Too many parameters given. See lunch --help\u0026#34; 1\u0026gt;\u0026amp;2 return 1 fi # 3个重要的变量 local product release variant # 从参数中提取3个变量； # 旧格式处理方式，带-的选项就是旧格式，如果解析出来任一变量为空，就报错； # 如果不带-，就按照新格式处理； # Handle the legacy format local legacy=$(echo $1 | grep \u0026#34;-\u0026#34;) if [[ $# -eq 1 \u0026amp;\u0026amp; -n $legacy ]]; then IFS=\u0026#34;-\u0026#34; read -r product release variant \u0026lt;\u0026lt;\u0026lt; \u0026#34;$1\u0026#34; if [[ -z \u0026#34;$product\u0026#34; ]] || [[ -z \u0026#34;$release\u0026#34; ]] || [[ -z \u0026#34;$variant\u0026#34; ]]; then echo \u0026#34;Invalid lunch combo: $1\u0026#34; 1\u0026gt;\u0026amp;2 echo \u0026#34;Valid combos must be of the form \u0026lt;product\u0026gt;-\u0026lt;release\u0026gt;-\u0026lt;variant\u0026gt; when using\u0026#34; 1\u0026gt;\u0026amp;2 echo \u0026#34;the legacy format. Run \u0026#39;lunch --help\u0026#39; for usage.\u0026#34; 1\u0026gt;\u0026amp;2 return 1 fi fi # 新格式只要product， 其他两个默认为trunk_staging和eng # Handle the new format. if [[ -z $legacy ]]; then product=$1 release=$2 if [[ -z $release ]]; then release=trunk_staging fi variant=$3 if [[ -z $variant ]]; then variant=eng fi fi # 下一步调用 # Validate the selection and set all the environment stuff _lunch_meat $product $release $variant } 设置环境变量和调用build_build_var_cache，缓存编译要用到的变量； 检查build_build_var_cache是否执行成功； 从缓存里面导出TARGET_PRODUCT和TARGET_BUILD_VARIANT环境变量； export TARGET_RELEASE、 TARGET_BUILD_TYPE等环境变量； 判断是否开启安静模式，安静模式就不输出；非安静模式下，如果还有spam_for_lunch脚本，就把这个脚本也加载； set_stuff_for_environment，里面是设置了其他一些环境变量； 检查多用户配置； function _lunch_meat() { local product=$1 # 定义局部变量 product，赋值为第一个参数 local release=$2 # 定义局部变量 release，赋值为第二个参数 local variant=$3 # 定义局部变量 variant，赋值为第三个参数 # 设置环境变量并调用 build_build_var_cache 函数缓存构建变量 TARGET_PRODUCT=$product \\ TARGET_RELEASE=$release \\ TARGET_BUILD_VARIANT=$variant \\ build_build_var_cache # 检查 build_build_var_cache 的执行结果是否成功 if [ $? -ne 0 ]; then # 如果 product 包含 \u0026#34;_eng\u0026#34;、\u0026#34;_user\u0026#34; 或 \u0026#34;_userdebug\u0026#34;，提示用户可能是下划线使用错误 if [[ \u0026#34;$product\u0026#34; =~ .*_(eng|user|userdebug) ]]; then echo \u0026#34;Did you mean -${product/*_/}? (dash instead of underscore)\u0026#34; fi return 1 # 返回错误码 1 表示失败 fi # 从缓存中获取并导出最终的 TARGET_PRODUCT 和 TARGET_BUILD_VARIANT 环境变量 export TARGET_PRODUCT=$(_get_build_var_cached TARGET_PRODUCT) export TARGET_BUILD_VARIANT=$(_get_build_var_cached TARGET_BUILD_VARIANT) # 导出其他必要的环境变量 export TARGET_RELEASE=$release # 导出 TARGET_RELEASE 变量 # 注意：这里的 \u0026#34;release\u0026#34; 是一个固定的字符串，而不是变量的值 export TARGET_BUILD_TYPE=release # 如果未设置 ANDROID_QUIET_BUILD（安静模式），则打印空行 [[ -n \u0026#34;${ANDROID_QUIET_BUILD:-}\u0026#34; ]] || echo # 调用 set_stuff_for_environment 设置构建环境 set_stuff_for_environment # 如果未启用安静模式，则打印当前配置信息 [[ -n \u0026#34;${ANDROID_QUIET_BUILD:-}\u0026#34; ]] || printconfig # 如果未启用安静模式，并且存在 spam_for_lunch 脚本，则运行该脚本提供额外提示 if [[ -z \u0026#34;${ANDROID_QUIET_BUILD}\u0026#34; ]]; then local spam_for_lunch=$(gettop)/build/make/tools/envsetup/spam_for_lunch if [[ -x $spam_for_lunch ]]; then $spam_for_lunch fi fi # 清理构建变量缓存 destroy_build_var_cache # 如果设置了 CHECK_MU_CONFIG，则检查多用户配置 if [[ -n \u0026#34;${CHECK_MU_CONFIG:-}\u0026#34; ]]; then check_mu_config fi } 总结 加载了一堆环境变量； m命令 源码解析 一般我们敲命令的时候是敲m -j 32，然后在这里会编程，执行命令的时候，一般在android根目录下面以rootpath替代 m # 引入 shell_utils.sh 脚本，该脚本通常包含一些辅助函数。 # $(dirname $BASH_SOURCE) 获取当前脚本所在的目录，然后通过 cd 和 pwd 找到其绝对路径， # 最终定位到 ../../make/shell_utils.sh 文件并加载它。 source $(cd $(dirname $BASH_SOURCE) \u0026amp;\u0026gt; /dev/null \u0026amp;\u0026amp; pwd)/../../make/shell_utils.sh # 调用 require_top 函数，确保环境变量 $TOP 已正确设置为项目的顶级目录。 # 如果 $TOP 未设置或无效，require_top 可能会报错并退出脚本。 require_top # 调用 _wrap_build 函数，执行 Soong 构建系统的核心逻辑。 # 参数说明： # \u0026#34;$TOP/build/soong/soong_ui.bash\u0026#34;：指定要运行的构建脚本（Soong 的入口脚本）。 # --build-mode：以build模式运行 Soong。 # --all-modules：编译所有模块。 # --dir=\u0026#34;$(pwd)\u0026#34;：指定当前工作目录作为build的上下文。 # \u0026#34;$@\u0026#34;：将脚本接收到的所有参数传递给 soong_ui.bash。 _wrap_build \u0026#34;$TOP/build/soong/soong_ui.bash\u0026#34; --build-mode --all-modules --dir=\u0026#34;$(pwd)\u0026#34; \u0026#34;$@\u0026#34; # 返回上一步命令的退出状态码，决定脚本是否成功执行。 # 如果构建成功，返回 0；否则返回非零值表示失败。 exit $? _wrap_build 如果是安静模式，就直接运行了； 如果不是安静模式，会先后打印一些信息； 这里其实没有实际编译作用，但是是个可以借鉴的脚本写法； 去掉这些杂七杂八的，命令是**\u0026quot;$TOP/build/soong/soong_ui.bash\u0026quot; \u0026ndash;build-mode \u0026ndash;all-modules \u0026ndash;dir=rootpath -j 32** # 漂亮地打印构建状态和持续时间 function _wrap_build() { # 如果设置了 ANDROID_QUIET_BUILD 为 true，则直接执行传入的命令，不显示额外信息 if [[ \u0026#34;${ANDROID_QUIET_BUILD:-}\u0026#34; == true ]]; then \u0026#34;$@\u0026#34; return $? fi # 记录构建开始时间（以秒为单位） local start_time=$(date +\u0026#34;%s\u0026#34;) # 执行传入的命令（\u0026#34;$@\u0026#34; 表示所有参数） \u0026#34;$@\u0026#34; # 获取命令的返回值（构建结果） local ret=$? # 记录构建结束时间 local end_time=$(date +\u0026#34;%s\u0026#34;) # 计算构建总耗时（秒数） local tdiff=$(($end_time-$start_time)) # 将总耗时转换为小时、分钟和秒 local hours=$(($tdiff / 3600 )) # 总耗时除以 3600 得到小时数 local mins=$((($tdiff % 3600) / 60)) # 剩余时间除以 60 得到分钟数 local secs=$(($tdiff % 60)) # 剩余时间为秒数 # 检查终端是否支持颜色输出（通过 tput colors 判断） local ncolors=$(tput colors 2\u0026gt;/dev/null) if [ -n \u0026#34;$ncolors\u0026#34; ] \u0026amp;\u0026amp; [ $ncolors -ge 8 ]; then # 如果支持 8 色及以上，定义颜色变量 color_failed=$\u0026#39;\\E\u0026#39;\u0026#34;[0;31m\u0026#34; # 红色，表示失败 color_success=$\u0026#39;\\E\u0026#39;\u0026#34;[0;32m\u0026#34; # 绿色，表示成功 color_warning=$\u0026#39;\\E\u0026#39;\u0026#34;[0;33m\u0026#34; # 黄色，表示警告 color_reset=$\u0026#39;\\E\u0026#39;\u0026#34;[00m\u0026#34; # 重置颜色 else # 如果不支持颜色输出，清空颜色变量 color_failed=\u0026#34;\u0026#34; color_success=\u0026#34;\u0026#34; color_reset=\u0026#34;\u0026#34; fi # 打印空行，用于分隔输出 echo # 根据构建结果打印不同的消息 if [ $ret -eq 0 ] ; then # 如果构建成功，打印绿色的成功消息 echo -n \u0026#34;${color_success}#### build completed successfully \u0026#34; else # 如果构建失败，打印红色的失败消息 echo -n \u0026#34;${color_failed}#### failed to build some targets \u0026#34; fi # 根据耗时的不同范围，格式化输出时间 if [ $hours -gt 0 ] ; then # 如果耗时超过 1 小时，显示小时、分钟和秒 printf \u0026#34;(%02d:%02d:%02d (hh:mm:ss))\u0026#34; $hours $mins $secs elif [ $mins -gt 0 ] ; then # 如果耗时超过 1 分钟但不足 1 小时，显示分钟和秒 printf \u0026#34;(%02d:%02d (mm:ss))\u0026#34; $mins $secs elif [ $secs -gt 0 ] ; then # 如果耗时不足 1 分钟，仅显示秒数 printf \u0026#34;(%d seconds)\u0026#34; $secs fi # 打印结束标志并重置颜色 echo \u0026#34; ####${color_reset}\u0026#34; # 打印空行，用于分隔输出 echo # 返回构建命令的原始退出码 return $ret } soong_ui.bash 前面加载工具类、记录时间、检查TOP变量、输出环境变量等等； 加载microfactory.bash脚本； 编译soong_ui、mk2rbc、rbcrun、release-config 4个工具； \u0026ldquo;$(getoutdir)/soong_ui\u0026rdquo; \u0026ldquo;$@\u0026rdquo; \u0026ndash;\u0026gt; $(getoutdir)/soong_ui \u0026ndash;build-mode \u0026ndash;all-modules \u0026ndash;dir=rootpath -j 32 # 引入 shell_utils.sh 脚本，提供一些辅助函数。 # 通过 $(dirname $BASH_SOURCE) 获取当前脚本所在的目录，然后定位到 ../make/shell_utils.sh 文件并加载它。 source $(cd $(dirname $BASH_SOURCE) \u0026amp;\u0026gt; /dev/null \u0026amp;\u0026amp; pwd)/../make/shell_utils.sh # 确保环境变量 $TOP 已正确设置为项目的顶级目录。 require_top # 记录 Soong 构建系统启动的时间戳，用于后续性能分析。 case $(uname -s) in Darwin) # 如果操作系统是 macOS export TRACE_BEGIN_SOONG=`$TOP/prebuilts/build-tools/path/darwin-x86/date +%s%3N` ;; *) # 其他操作系统（如 Linux） export TRACE_BEGIN_SOONG=$(date +%s%N) ;; esac # 设置 COG 环境（如果需要），COG 是 Android 构建系统中的一个工具。 setup_cog_env_if_needed # 保存当前的工作目录（PWD），以便在 soong_ui 中使用。 export ORIGINAL_PWD=${PWD} # 获取项目的顶级目录并导出为环境变量 $TOP。 export TOP=$(gettop) # 加载 Soong 构建系统的微工厂脚本 microfactory.bash。 source ${TOP}/build/soong/scripts/microfactory.bash # 使用 soong_build_go 编译多个 Go 语言工具： # 1. soong_ui：Soong 的核心构建工具。 soong_build_go soong_ui android/soong/cmd/soong_ui # 2. mk2rbc：将 Makefile 转换为 RBC（Rule-Based Compilation）格式的工具。 soong_build_go mk2rbc android/soong/mk2rbc/mk2rbc # 3. rbcrun：运行 RBC 文件的工具。 soong_build_go rbcrun rbcrun/rbcrun # 4. release-config：生成发布配置的工具。 soong_build_go release-config android/soong/cmd/release_config/release_config # 切换到项目的顶级目录。 cd ${TOP} # 执行编译好的 soong_ui 工具，并将所有传入参数传递给它。 exec \u0026#34;$(getoutdir)/soong_ui\u0026#34; \u0026#34;$@\u0026#34; build/soong/scripts/microfactory.bash 设置go环境变量； # 输入变量： # ${TOP}: Android 源码树的顶层目录 # ${OUT_DIR}: 输出目录位置（默认为 ${TOP}/out） # ${OUT_DIR_COMMON_BASE}: 更改默认输出目录为 # ${OUT_DIR_COMMON_BASE}/$(basename ${TOP}) # 确保 GOROOT 设置为树内的版本。 # 根据操作系统设置 GOROOT 环境变量。 case $(uname) in Linux) # 对于 Linux 系统，将 GOROOT 设置为 Linux x86 的预编译 Go 二进制文件路径 export GOROOT=\u0026#34;${TOP}/prebuilts/go/linux-x86/\u0026#34; ;; Darwin) # 对于 macOS 系统，将 GOROOT 设置为 macOS x86 的预编译 Go 二进制文件路径 export GOROOT=\u0026#34;${TOP}/prebuilts/go/darwin-x86/\u0026#34; ;; *) # 如果操作系统不被识别，打印错误信息并退出 echo \u0026#34;未知的操作系统:\u0026#34; $(uname) \u0026gt;\u0026amp;2 \u0026amp;\u0026amp; exit 1;; esac # 函数：获取输出目录 # 此函数确定构建输出的位置。 function getoutdir { # 获取 OUT_DIR 的值，如果未设置则使用空字符串 local out_dir=\u0026#34;${OUT_DIR-}\u0026#34; # 如果 OUT_DIR 未设置，则检查 OUT_DIR_COMMON_BASE 是否设置 if [ -z \u0026#34;${out_dir}\u0026#34; ]; then if [ \u0026#34;${OUT_DIR_COMMON_BASE-}\u0026#34; ]; then # 如果 OUT_DIR_COMMON_BASE 已设置，则构造输出目录路径 out_dir=\u0026#34;${OUT_DIR_COMMON_BASE}/$(basename ${TOP})\u0026#34; else # 否则，使用默认输出目录 \u0026#39;out\u0026#39; out_dir=\u0026#34;out\u0026#34; fi fi # 如果输出目录不是绝对路径，则在其前面加上 TOP 以使其成为绝对路径 if [[ \u0026#34;${out_dir}\u0026#34; != /* ]]; then out_dir=\u0026#34;${TOP}/${out_dir}\u0026#34; fi # 打印确定的输出目录路径 echo \u0026#34;${out_dir}\u0026#34; } # 函数：引导 microfactory 从源代码构建请求的二进制文件（如果必要） # 参数： # $1: 请求的二进制文件名称 # $2: 包名称 function soong_build_go { # 设置构建所需的环境变量 BUILDDIR=$(getoutdir) \\ # 输出目录 SRCDIR=${TOP} \\ # Android 源码树的顶层目录 BLUEPRINTDIR=${TOP}/build/blueprint \\ # Blueprint 目录 EXTRA_ARGS=\u0026#34;-pkg-path android/soong=${TOP}/build/soong \\ -pkg-path prebuilts/bazel/common/proto=${TOP}/prebuilts/bazel/common/proto \\ -pkg-path rbcrun=${TOP}/build/make/tools/rbcrun \\ -pkg-path google.golang.org/protobuf=${TOP}/external/golang-protobuf \\ -pkg-path go.starlark.net=${TOP}/external/starlark-go\u0026#34; \\ # 调用 build_go 函数，并传递提供的参数和额外参数 build_go $@ } # 引入 microfactory 脚本以包含其函数和配置 source ${TOP}/build/blueprint/microfactory/microfactory.bash build/blueprint/microfactory/microfactory.bash 检查microfactory bin文件是否已经生成（out目录下，bin文件是microfactory_\u0026lt;系统类型后缀\u0026gt;，我的是microfactory_Linux） 如果没有生成 \u0026ndash;\u0026gt; 使用 sed 命令将 package microfactory 改为 package main，并在文件末尾添加 main 函数调用 Main() \u0026ndash;\u0026gt; go run编译microfactory .go； 如果已经存在 \u0026ndash;\u0026gt; 使用已经存在的microfactory； 组件编译参数，使用microfactory_Linux bin文件编译指定模块； 如果microfactory_Linux 从源码编译，更新版本号； microfactory 模块2021年前会在github上进行维护，2021 年 5 月 3 日后，github上存档，AOSP内继续更新，并且 AOSP 中的 Blueprint 源代码树最终将不再在 Android 之外使用；（意思是以前microfactory可以运用在其他方面，归档之后仅能运用于Android了）； # 一组用于使用 microfactory 构建和运行 Go 代码的实用函数 # # 输入变量： # ${GOROOT} # ${BUILDDIR} # ${BLUEPRINTDIR} # ${SRCDIR} # 引导 microfactory 从源代码构建请求的二进制文件（如果必要） # # 参数： # $1: 请求的二进制文件名称 # $2: 包名称 # ${EXTRA_ARGS}: 传递给 microfactory 的额外参数 (-pkg-path 等) function build_go { # 当 microfactory 发生足够大的变化以至于无法重新构建自身时递增。 # 例如，如果我们使用了一个旧版本不支持的新命令行参数。 local mf_version=3 local mf_src=\u0026#34;${BLUEPRINTDIR}/microfactory\u0026#34; local mf_bin=\u0026#34;${BUILDDIR}/microfactory_$(uname)\u0026#34; local mf_version_file=\u0026#34;${BUILDDIR}/.microfactory_$(uname)_version\u0026#34; local built_bin=\u0026#34;${BUILDDIR}/$1\u0026#34; local from_src=1 # 检查 microfactory 二进制文件和版本文件是否存在，并且版本匹配 if [ -f \u0026#34;${mf_bin}\u0026#34; ] \u0026amp;\u0026amp; [ -f \u0026#34;${mf_version_file}\u0026#34; ]; then if [ \u0026#34;${mf_version}\u0026#34; -eq \u0026#34;$(cat \u0026#34;${mf_version_file}\u0026#34;)\u0026#34; ]; then from_src=0 fi fi local mf_cmd if [ $from_src -eq 1 ]; then # `go run` 需要一个单一的主包，因此创建一个 local gen_src_dir=\u0026#34;${BUILDDIR}/.microfactory_$(uname)_intermediates/src\u0026#34; mkdir -p \u0026#34;${gen_src_dir}\u0026#34; sed \u0026#34;s/^package microfactory/package main/\u0026#34; \u0026#34;${mf_src}/microfactory.go\u0026#34; \u0026gt;\u0026#34;${gen_src_dir}/microfactory.go\u0026#34; printf \u0026#34;\\n//for use with go run\\nfunc main() { Main() }\\n\u0026#34; \u0026gt;\u0026gt;\u0026#34;${gen_src_dir}/microfactory.go\u0026#34; mf_cmd=\u0026#34;${GOROOT}/bin/go run ${gen_src_dir}/microfactory.go\u0026#34; else mf_cmd=\u0026#34;${mf_bin}\u0026#34; fi # 删除之前的跟踪文件 rm -f \u0026#34;${BUILDDIR}/.$1.trace\u0026#34; # GOROOT 必须是绝对路径，因为 `go run` 会更改当前目录 GOROOT=$(cd $GOROOT; pwd) ${mf_cmd} -b \u0026#34;${mf_bin}\u0026#34; \\ -pkg-path \u0026#34;github.com/google/blueprint=${BLUEPRINTDIR}\u0026#34; \\ -trimpath \u0026#34;${SRCDIR}\u0026#34; \\ ${EXTRA_ARGS} \\ -o \u0026#34;${built_bin}\u0026#34; $2 # 如果构建成功并且是从源代码构建的，则更新版本文件 if [ $? -eq 0 ] \u0026amp;\u0026amp; [ $from_src -eq 1 ]; then echo \u0026#34;${mf_version}\u0026#34; \u0026gt;\u0026#34;${mf_version_file}\u0026#34; fi } 命令推演 至此，暂时回到soong_ui.bash soong_build_go soong_ui android/soong/cmd/soong_ui ↓ ↓ ↓ ↓ # soong_build_go 函数内部 BUILDDIR=$(getoutdir) \\ # 输出目录 SRCDIR=${TOP} \\ # Android 源码树的顶层目录 BLUEPRINTDIR=${TOP}/build/blueprint \\ # Blueprint 目录 EXTRA_ARGS=\u0026#34;-pkg-path android/soong=${TOP}/build/soong \\ -pkg-path prebuilts/bazel/common/proto=${TOP}/prebuilts/bazel/common/proto \\ -pkg-path rbcrun=${TOP}/build/make/tools/rbcrun \\ -pkg-path google.golang.org/protobuf=${TOP}/external/golang-protobuf \\ -pkg-path go.starlark.net=${TOP}/external/starlark-go\u0026#34; build_go soong_ui android/soong/cmd/soong_ui ↓ ↓ ↓ ↓ # build_go 函数内部 local mf_version=3 local mf_src=\u0026#34;${BLUEPRINTDIR}/microfactory\u0026#34; local mf_bin=\u0026#34;${BUILDDIR}/microfactory_$(uname)\u0026#34; local mf_version_file=\u0026#34;${BUILDDIR}/.microfactory_$(uname)_version\u0026#34; local built_bin=\u0026#34;${BUILDDIR}/soong_ui\u0026#34; local from_src=1 GOROOT=$(cd $GOROOT; pwd) ${mf_cmd} -b \u0026#34;${mf_bin}\u0026#34; \\ -pkg-path \u0026#34;github.com/google/blueprint=${BLUEPRINTDIR}\u0026#34; \\ -trimpath \u0026#34;${SRCDIR}\u0026#34; \\ ${EXTRA_ARGS} \\ -o \u0026#34;${built_bin}\u0026#34; android/soong/cmd/soong_ui ↓ ↓ ↓ ↓ # 最终版本 cd TOP/prebuilts/go/linux-x86/ # linux中go的环境变量路径 pwd # 打印绝对路径 GOROOT=$(cd $GOROOT; pwd) # 赋值绝对路径给GOROOT，因为上面说go run会导致相对路径有问题 # 如果是源码编译 ${TOP}/prebuilts/go/linux-x86/bin/go run ${TOP}/out/.microfactory_Linux_intermediates/src/microfactory.go -b microfactory_Linux \\ -pkg-path \u0026#34;github.com/google/blueprint=/build/blueprint=${TOP}/build/blueprint/microfactory\u0026#34; \\ -trimpath ${TOP} \\ -pkg-path android/soong=${TOP}/build/soong \\ -pkg-path prebuilts/bazel/common/proto=${TOP}/prebuilts/bazel/common/proto \\ -pkg-path rbcrun=${TOP}/build/make/tools/rbcrun \\ -pkg-path google.golang.org/protobuf=${TOP}/external/golang-protobuf \\ -pkg-path go.starlark.net=${TOP}/external/starlark-go\u0026#34; -o \u0026#34;/out/soong_ui\u0026#34; android/soong/cmd/soong_ui # 如果是生成物 microfactory_Linux -b microfactory_Linux \\ -pkg-path \u0026#34;github.com/google/blueprint=/build/blueprint=${TOP}/build/blueprint/microfactory\u0026#34; \\ -trimpath ${TOP} \\ -pkg-path android/soong=${TOP}/build/soong \\ -pkg-path prebuilts/bazel/common/proto=${TOP}/prebuilts/bazel/common/proto \\ -pkg-path rbcrun=${TOP}/build/make/tools/rbcrun \\ -pkg-path google.golang.org/protobuf=${TOP}/external/golang-protobuf \\ -pkg-path go.starlark.net=${TOP}/external/starlark-go\u0026#34; -o \u0026#34;/out/soong_ui\u0026#34; android/soong/cmd/soong_ui 其他3条mk2rbc、rbcrun、release-config的编译命令一样，可以自行推理；\n总结： microfactory是一个go语言写的编译框架，使用go语言编译，以前可以在许多领域通用，2021年后仅在AOSP适用； 封装了build_go和soong_build_go两个方法，使用microfactory编译了soong_ui、mk2rbc、rbcrun、release-config命令； 得到soong_ui后，直接使用soong_ui命令； 于是编译命令变成了out/soong_ui \u0026ndash;build-mode \u0026ndash;all-modules \u0026ndash;dir=rootpath -j 32 ","permalink":"http://localhost:1313/posts/aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B1%E8%84%9A%E6%9C%AC%E7%AF%87/","summary":"AOSP编译流程1（脚本篇）","title":"AOSP编译流程1（脚本篇）"},{"content":"Reason \u0026amp; Steps Reason:\n检查壁纸服务是否运行 \u0026ndash; 根据源码和日志查看不运行的原因\n分析 通过服务列表查看壁纸服务是否运行 service list | grep wall -i 通过源码发现 system_server通过判断config_enableWallpaperService是否为true决定是否拉起WallpaperManagerService； 查找config_enableWallpaperService配置，发现在图片以下地方都有存在此配置； ./frameworks/base/core/res/res/values/symbols.xml:335 ./frameworks/base/core/res/res/values/config.xml:1634 ---------------- 此处为framework的配置 ./packages/services/Car/car_product/overlay/frameworks/base/core/res/res/values/config.xml:111 --------- 此为Automotive Car的配置，利用overlay机制覆盖原本framework的机制 logcat -v color -b system 查看wallpaper确定是否由于config原因无法起来 这里和上面代码的日志一致\n解决办法 将上面config_enableWallpaperService相关配置改为true； 通过make framework-res​编译framework生成物； 找到以下生成物，并替换到真机对应位置： out/target/product/msmnile_gvmq/system/framework/framework-res.apk out/target/product/msmnile_gvmq/system/product/overlay/framework-res__auto_generated_rro_product.apk 补充说明：\nframework-res__auto_generated_rro_product.apk是framework-res.apk的Overlay的apk，属于overlay RRO(Runtime Resource Overlay)方式，因此仅改写framework-res是不够的，还需要将这里（重点是将这里）改写成true；\n","permalink":"http://localhost:1313/posts/carlauncher-can-not-show-wallpaper--carlauncher%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%A3%81%E7%BA%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","summary":"CarLauncher can not show wallpaper  CarLauncher无法显示壁纸问题解决","title":"CarLauncher can not show wallpaper  CarLauncher无法显示壁纸问题解决"},{"content":"现象：已经设置了壁纸，壁纸服务也有启动，但是仍不可显示壁纸\n思考方向：系统各个App页面层级排查\n最终解决办法：\n在Application的主题中，添加透明背景和允许壁纸显示属性\n\u0026lt;style name=\u0026#34;Theme.Launcher\u0026#34; parent=\u0026#34;Theme.CarUi.NoToolbar\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowBackground\u0026#34;\u0026gt;@android:color/transparent\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowShowWallpaper\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;textAppearanceGridItem\u0026#34;\u0026gt;@android:style/TextAppearance.DeviceDefault.Medium\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;textAppearanceGridItemSecondary\u0026#34;\u0026gt;@android:style/TextAppearance.DeviceDefault.Small\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 切记不要在主页Activity进行设置，父类主题可能设置背景，导致背景不透明失效：\n","permalink":"http://localhost:1313/posts/carlauncher%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%A3%81%E7%BA%B8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3---%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E5%AF%BC%E8%87%B4/","summary":"CarLauncher无法显示壁纸问题解决 - 主题设置导致","title":"CarLauncher无法显示壁纸问题解决 - 主题设置导致"},{"content":"Android适配说明 系统适配 QTI Vehicle与 自定义 Vehicle冲突 服务冲突 Vehicle HAL 是安卓AAOS（Android Automitive OS）的最底层， 虽然AOSP官网默认不支持自行添加Property， 但是国内一贯的做法，都是新增自定义的Property，对应底层QNX、MCU协议或者CAN信号，以此传递APP-车身功能的通信的一环；\n按照文档中STR的时序图(STR Sequence Flowsheet)，VHAL需要监听按键输入 /dev/input/event0 power按键， 当power按键按下， 需要向上发送AP_POWER_STATE_REQ属性， SHUTDOWN_PREPARE状态；\n上述两点需求，导致了实现合并STR和自定义的Property，方案有多种：\n方案一：自定义VehicleHAL + 监听/dev/input/event0按键节点，收到节点后往上发送AP_POWER_STATE_REQ属性， SHUTDOWN_PREPARE状态；（现使用） 方案二：两个VHAL共存，因为QTI VHAL占用了default注册，自定义的VHAL需要修改注册名，两者在CarService进行合并，实现过，但是破坏了安卓标准接口，也破坏了CarService原有的设计，代码修改较为生硬； 方案三：QTI-VHAL也是依赖DefaultVehicleHal和VehicleHardware等AOSP原生模块，可以考虑在这些模块链路中间实现拦截，将自定义的Proeprty进行自定义处理，原生Property留给QTI处理，理论上能尽可能保留两者，但这个也是最近灵机一动想出来的，可行性待验证； 补充：/dev/input/event0只是一个INPUT节点，使用power按键作为QNX通知Android进入STR的通信手段，实际上Android自行发起SUSPEND，或者QNX通过SOA等方式告诉Android需要进入STR，也能够达到同样效果。如果是这样的话，也无需考虑是否适配QTI VHAL的问题了。\n方案一修改点：\nVHAL中通过EPOLL监听/dev/input/event0节点，收到POWER按键之后，即开始向上发送发送AP_POWER_STATE_REQ属性， SHUTDOWN_PREPARE状态； 因为涉及event，rc文件的group中添加input用户组，保证能够监听INPUT节点； service vendor.vehicle-hal-maxj /vendor/bin/hw/android.hardware.automotive.vehicle@V1-maxj-service class early_hal user vehicle_network group system inet input AP_POWER_STATE_REQ配置与参数 配置修改 修改说明：如果需要开启STR，除了处理QTI VHAL和Maxj VHAL冲突以外，还需要设置AP_POWER_STATE_REQ的参数，将对应configArray的参数设置为255（或者7）； 参数说明： VHAL配置中有个configArray，允许对每个ID进行一个组数值配置，在代码中进行自定义的判断处理； 这里的值定义对应VehicleApPowerStateConfigFlag，代表3个配置，是否支持休眠（Suspend to RAM）、是否支持设置睡眠后定时启动、是否支持睡眠（Suspend to Disk）； 在CarPowerMangerService中，通过PowerHalService进行判断； hardware/automotive/vehicle/aidl/impl/default_config/config/DefaultProperties.json { \u0026#34;property\u0026#34;: \u0026#34;VehicleProperty::AP_POWER_STATE_REQ\u0026#34;, \u0026#34;configArray\u0026#34;: [ - 0 + 255 ], \u0026#34;access\u0026#34;: \u0026#34;VehiclePropertyAccess::READ\u0026#34;, \u0026#34;changeMode\u0026#34;: \u0026#34;VehiclePropertyChangeMode::ON_CHANGE\u0026#34; enum VehicleApPowerStateConfigFlag { ENABLE_DEEP_SLEEP_FLAG = 0x1, CONFIG_SUPPORT_TIMER_POWER_ON_FLAG = 0x2, ENABLE_HIBERNATION_FLAG = 0x4, } 休眠默认值上报 修改说明：需要开启STR，还需要VHAL上报的参数正确，AP_POWER_STATE_REQ这个ID对应的Value是一个int32数组，第一个已确定为 VehicleApPowerStateReq::SHUTDOWN_PREPARE 状态； 第二个需要填写VehicleApPowerStateShutdownParam::CAN_SLEEP，才可以表示休眠，最后进入休眠状态，填0表示不使用，默认为SHUTDOWN关机状态，其他状态相应参考VehicleApPowerStateShutdownParam定义； APP/HAL STR规范 这部分按照开发经验撰写，本次调试过程中，Android均可休眠。可供后续参考。\n资源释放 根据过往经验，APP和HAL服务等如果使用到系统资源，在进入休眠时，尽量将资源进行释放，包括但不限于以下资源：\n停止数据传输接口，如SPI、I²C、UART等等； 关闭摄像头； 关闭视频会话； 关闭音频会话； 停止OpenGL渲染； 关闭屏幕； 关闭USB； 状态记忆 音乐/电台等需要记忆上次播放状态、进度、播放曲目、波段、内容等等； Android系统重启 Android系统长时间运行，内存碎片会导致系统卡顿，需要定期自动重启，建议以下条件满足时，可以进行Android系统重启\n系统运行时长累计运行超过60小时或者休眠次数达20h； 档位处于P档； 车速为0； 时间尽量选择凌晨时间； 用车情况：重启前1小时未被唤醒； 以上为Android重启的建议需求，建议安排合理需求，定时对整机进行冷启动重启；\n监听电源状态代码 Java示例代码 car = Car.createCar(mContext); // 获取CAR carManager = (CarPowerManager) car.getCarManager(Car.POWER_SERVICE); // 获取CarPowerManager carManager.setListener(mContext.getMainExecutor(), new CarPowerManager.CarPowerStateListener() { // 监听CarPowerState @Override public void onStateChanged(int i) { @CarPowerManager.CarPowerState int state = i; Log.i(TAG, \u0026#34;onStateChanged: \u0026#34; + i); // do somthing ... } }); C++示例代码 // 获取AIDL Vehicle // 参考 packages/services/Car/cpp/vhal/client/src/AidlVhalClient.cpp // hardware/interfaces/automotive/vehicle/vts/src/VtsHalAutomotiveVehicle_TargetTest.cpp 参数是 AP_POWER_STATE_REQ 、 areaId为0 、 采样率为 0 （OnChange类型，此参数无用） class VehicleCallback : public IVehicleCallback::BnVehicleCallback { public: ndk::ScopedAStatus onPropertyEvent( const std::vector\u0026lt;VehiclePropValue\u0026gt;\u0026amp; values) override { for (const auto\u0026amp; value : values) { if (value.prop == static_cast\u0026lt;int32_t\u0026gt;(VehicleProperty::AP_POWER_STATE_REQ)) { if (!value.value.int32Values.empty()) { LOG(INFO) \u0026lt;\u0026lt; \u0026#34;AP_POWER_STATE_REQ changed: \u0026#34; \u0026lt;\u0026lt; value.value.int32Values[0]; // 处理状态变化： // 0 = WAIT_FOR_VHAL // 1 = DEEP_SLEEP_EXIT // 2 = SHUTDOWN_PREPARE // 3 = CANCEL_SHUTDOWN } } } return ndk::ScopedAStatus::ok(); } ndk::ScopedAStatus onPropertySet(const VehiclePropValue\u0026amp; value) override { // 属性设置事件（此处不需要处理） return ndk::ScopedAStatus::ok(); } ndk::ScopedAStatus onPropertySetError( const std::vector\u0026lt;VehiclePropError\u0026gt;\u0026amp; errors) override { for (const auto\u0026amp; error : errors) { LOG(ERROR) \u0026lt;\u0026lt; \u0026#34;Property set error: \u0026#34; \u0026lt;\u0026lt; error.propId \u0026lt;\u0026lt; \u0026#34; in area \u0026#34; \u0026lt;\u0026lt; error.areaId; } return ndk::ScopedAStatus::ok(); } }; const std::string instance = std::string(IVehicle::descriptor) + \u0026#34;/default\u0026#34;; // 获取IVehicle服务实例 std::shared_ptr\u0026lt;IVehicle\u0026gt; vehicle = IVehicle::fromBinder( ndk::SpAIBinder(AServiceManager_getService(instance.c_str()))); if (!vehicle) { LOG(ERROR) \u0026lt;\u0026lt; \u0026#34;Failed to get IVehicle service\u0026#34;; return 1; } // 创建我们的回调对象 auto callback = ndk::SharedRefBase::make\u0026lt;VehicleCallback\u0026gt;(); // 设置订阅选项 SubscribeOptions options = { .propId = static_cast\u0026lt;int32_t\u0026gt;(VehicleProperty::AP_POWER_STATE_REQ), .areaIds = {0}, // 全局区域 .sampleRate = 0.0f, // 事件触发模式（非周期性） }; // 执行订阅 ndk::ScopedAStatus status = vehicle-\u0026gt;subscribe(callback, {options}); if (!status.isOk()) { LOG(ERROR) \u0026lt;\u0026lt; \u0026#34;Subscribe failed: \u0026#34; \u0026lt;\u0026lt; status.getMessage(); return 1; } LOG(INFO) \u0026lt;\u0026lt; \u0026#34;Successfully subscribed to AP_POWER_STATE_REQ\u0026#34;; APP/HAL STR规范 car = Car.createCar(mContext); // 获取CAR carManager = (CarPowerManager) car.getCarManager(Car.POWER_SERVICE); // 获取CarPowerManager carManager.setListener(mContext.getMainExecutor(), new CarPowerManager.CarPowerStateListener() { // 监听CarPowerState @Override public void onStateChanged(int i) { @CarPowerManager.CarPowerState int state = i; Log.i(TAG, \u0026#34;onStateChanged: \u0026#34; + i); // do somthing ... } }); 调试说明 调试步骤按照《80-73603-1_REV_AA_Gen3_and_Gen4_STR_Debug_User_Guide》文档调试即可； 步骤： 1. 关闭蓝牙、WiFi、USB USB关闭命令为 #echo none \u0026gt; /sys/bus/platform/devices/a800000.ssusb/mode // pass through usb devices #echo none \u0026gt; /sys/bus/platform/devices/a600000.ssusb/mode 2. 从QNX侧模拟发送Power按键到安卓 #echo power \u0026gt;/dev/qvm/la/powerkey 3. QNX侧查看QVM状态 cat /dev/qvm/la/power_status // 实测发现，power_status不存在，无法判别，因此通过adb是否能够连上安卓来进行判别 // 如果安卓完全关机，并非进入休眠，qvm/la文件夹不存在 ","permalink":"http://localhost:1313/posts/qualcomm8775-qtivehicle%E4%B8%8E%E5%8E%9F%E7%94%9Fvehicle-str%E9%97%AE%E9%A2%98%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/","summary":"Qualcomm8775 QTIVehicle与原生Vehicle STR问题冲突解决","title":"Qualcomm8775 QTIVehicle与原生Vehicle STR问题冲突解决"},{"content":"报错 clang-3289846/lib64/clang/3.8/include/mm3dnow.h clang-32898 Aborting error: prebuilts/clang/host/linux-x86/: platform/prebuilts/clang/host/linux-x86 checkout 822e367c6d8007296d01b87fa18b187257c2be0f error: Cannot checkout platform/prebuilts/clang/host/linux-x86 Checking out: 100% (1423/1423), done in 31.598s error: Unable to fully sync the tree error: Checking out local projects failed. Failing repos: device/google/sunfish-kernel prebuilts/misc prebuilts/abi-dumps/vndk prebuilts/clang/host/linux-x86 prebuilts/rust Try re-running with \u0026#34;-j1 --fail-fast\u0026#34; to exit at the first error. ================================================================================ Repo command failed due to the following `SyncError` errors: device/google/sunfish-kernel checkout 02079225c56fa70a0b729a6c5eae909e848a2e5e platform/prebuilts/misc checkout 83065adae342205df04abe16bb1b46527ce08795 platform/prebuilts/abi-dumps/vndk checkout 67cbeb44c901c5c41b75b8dc42aa893c583d9b74 platform/prebuilts/clang/host/linux-x86 checkout 822e367c6d8007296d01b87fa18b187257c2be0f platform/prebuilts/rust checkout cec82598fd463dc3977e0245599bf52706e3688c root@xxx-virtual-machine:/home/xxx/android/AOSP# root@xxx-virtual-machine:/home/xxx/android/AOSP# root@xxx-virtual-machine:/home/xxx/android/AOSP# rm -rf device/google/sunfish- sunfish-kernel/ sunfish-sepolicy/ root@xxx-virtual-machine:/home/xxx/android/AOSP# rm -rf device/google/sunfish-kernel/ root@xxx-virtual-machine:/home/xxx/android/AOSP# rm -rf prebuilts/misc/ root@xxx-virtual-machine:/home/xxx/android/AOSP# rm -rf prebuilts/abi-dumps/vndk/ root@xxx-virtual-machine:/home/xxx/android/AOSP# rm -rf prebuilts/clang/host/linux-x86/ root@xxx-virtual-machine:/home/xxx/android/AOSP# rm -rf prebuilts/runtime/ root@xxx-virtual-machine:/home/xxx/android/AOSP# rm -rf prebuilts/r r8/ remoteexecution-client/ rust/ root@xxx-virtual-machine:/home/xxx/android/AOSP# rm -rf prebuilts/rust/ root@xxx-virtual-machine:/home/xxx/android/AOSP# repo sync -c -j8 Fetching: 100% (1423/1423), done in 26.893s Updating files: 100% (1007/1007), done.xternal/rust/crates/lru-cacheUpdating files: 100% (1007/1007) 处理 删除repo fail的文件夹， 重新repo sync即可； Preferences master分支仓库更新方法_try re-running with \u0026ldquo;-j1 \u0026ndash;fail-fast\u0026rdquo; to exit at t-CSDN博客 ","permalink":"http://localhost:1313/posts/repo-sync%E6%8A%A5%E9%94%99-failing-repos-try-re-running-with--j1---fail-fast-to-exit-at-the-first-error/","summary":"repo sync报错 Failing Repos Try re-running with -j1 \u0026ndash;fail-fast to exit at the first error","title":"repo sync报错 Failing Repos Try re-running with -j1 --fail-fast to exit at the first error"},{"content":"问题描述 top命令查看当前进程CPU过高\n进程名：android.hardware.automotive.vehicle@2.0-service\n版本：Android11\nTasks: 372 total, 4 running, 368 sleeping, 0 stopped, 0 zombie Mem: 8047016K total, 6529068K used, 1517948K free, 135968K buffers Swap: 4194300K total, 0 used, 4194300K free, 1814164K cached 800%cpu 297%user 40%nice 307%sys 136%idle 8%iow 9%irq 4%sirq 0%host PID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ ARGS 1175 system 18 -2 17G 306M 173M S 100 3.8 19:42.93 system_server 19281 vehicle_net+ 20 0 12G 10M 6.4M S 49.1 0.1 5:46.15 android.hardware.automotive.vehicle@2.0-service 276 logd 30 10 12G 174M 2.7M S 35.4 2.2 7:19.32 logd 排查流程 查看进程CPU占用率 console:/ # top -p 19281 Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie Mem: 8047016K total, 7306672K used, 740344K free, 147348K buffers Swap: 4194300K total, 0 used, 4194300K free, 1821408K cached 800%cpu 290%user 57%nice 302%sys 124%idle 13%iow 9%irq 4%sirq 0%host PID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ ARGS 19281 vehicle_net+ 20 0 12G 10M 6.4M S 49.3 0.1 14:27.25 android.hardware.automotive.vehicle@2.0-service 从top命令查看得知，CPU是8核的处理器， vehicle进程占用约50%， 按百分比计算约占用6%左右。\n查看线程CPU占用率 console:/ # top -H -p 19281 Threads: 18 total, 0 running, 18 sleeping, 0 stopped, 0 zombie Mem: 8047016K total, 7264500K used, 782516K free, 147696K buffers Swap: 4194300K total, 0 used, 4194300K free, 1821928K cached 800%cpu 370%user 89%nice 322%sys 7%idle 0%iow 7%irq 4%sirq 0%host TID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ THREAD PROCESS 19303 vehicle_net+ 20 0 12G 10M 6.4M S 22.2 0.1 3:46.03 HwBinder:19281_ android.hardware.automotive.vehicle@2.0-service 19307 vehicle_net+ 20 0 12G 10M 6.4M S 18.5 0.1 3:48.29 HwBinder:19281_ android.hardware.automotive.vehicle@2.0-service 20072 vehicle_net+ 20 0 12G 10M 6.4M S 7.4 0.1 3:47.50 HwBinder:19281_ android.hardware.automotive.vehicle@2.0-service 20058 vehicle_net+ 20 0 12G 10M 6.4M S 7.4 0.1 3:46.76 HwBinder:19281_ android.hardware.automotive.vehicle@2.0-service 19311 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.02 Binder:19281_3 android.hardware.automotive.vehicle@2.0-service 19304 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.49 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19310 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.00 Binder:19281_1 android.hardware.automotive.vehicle@2.0-service 19298 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.00 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19291 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.10 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19301 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.01 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19299 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.07 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19294 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.00 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19295 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:05.85 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19296 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.00 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19297 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.00 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19290 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.00 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19289 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.00 vehicle@2.0-ser android.hardware.automotive.vehicle@2.0-service 19281 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 0:00.62 Binder:19281_2 android.hardware.automotive.vehicle@2.0-service 可以看到其中占用较高的是线程19303、19307、20072、20058， 该4个线程线程名均有HwBinder，是HwBinder相关的线程。Android进程中，Binder相关的线程，基本上可以认定跟跨进程通信有关。binder和vndbinder使用的是AIDL接口， hwbinder使用的是HIDL接口。 这里能基本确定是有其他进程频繁调用Vehicle服务的接口引起的。\n查找Binder客户端 既然清楚是因为有其他进程频繁调用引起，那么下一步就是需要找出该调用的客户端了。在对外提供的接口上，加上binder pid和uid的打印。以此来查找对应的进程。\nint pid = IPCThreadState::self()-\u0026gt;getCallingPid(); int uid = IPCThreadState::self()-\u0026gt;getCallingUid(); ALOGI(\u0026#34;%s Prop: 0x%x, PID: %d, UID: %d \u0026#34;, __func__, requestedPropValue.prop, pid, uid); 修改、替换后打印logcat日志，得知调用的PID为19915， UID为0，多次调用中基本没有停顿。\n04-01 14:42:51.169 19281 19307 I DefaultVehicleHal_v2_0: get Prop: 0x294034c2, PID: 19915, UID: 0 04-01 14:42:51.169 19281 19307 I DefaultVehicleHal_v2_0: get Prop: 0x11400409, PID: 19915, UID: 0 根据PID，查找对应的服务（这里用xxx替代）\n130|console:/ # ps -A | grep 19915 root 19915 1 12493068 27708 futex_wait_queue_me 0 S xxx_service 验证流程 删除调用的服务，先把调用的进程改名备份 adb root adb remount adb shell \u0026#34;mv /system/bin/xxx_service /system/bin/xxx_service1\u0026#34; kill掉调用进程 130|console:/ # ps -A | grep xxx_service root 19915 1 12493068 27708 futex_wait_queue_me 0 S xxx_service 130|console:/ # kill 19915 查看进程CPU占用 console:/ # top -p 19281 Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie Mem: 8047016K total, 7683740K used, 363276K free, 150140K buffers Swap: 4194300K total, 0 used, 4194300K free, 1829356K cached 800%cpu 182%user 64%nice 257%sys 264%idle 21%iow 7%irq 4%sirq 0%host PID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ ARGS 19281 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 23:23.91 android.hardwa+ Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie Mem: 8047016K total, 7682600K used, 364416K free, 150140K buffers Swap: 4194300K total, 0 used, 4194300K free, 1829356K cached 800%cpu 182%user 64%nice 257%sys 264%idle 21%iow 7%irq 4%sirq 0%host PID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ ARGS 19281 vehicle_net+ 20 0 12G 10M 6.4M S 0.0 0.1 23:23.91 android.hardware.automotive.vehicle@2.0-service 至此可看到Vehicle进程CPU占用恢复正常， 通知xxx_service排查。 ","permalink":"http://localhost:1313/posts/%E8%BF%9B%E7%A8%8B%E6%8E%A5%E5%8F%A3%E8%A2%AB%E9%A2%91%E7%B9%81%E8%B0%83%E7%94%A8%E8%87%B4cpu%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98%E6%8E%92%E6%9F%A5%E6%B5%81%E7%A8%8B/","summary":"进程接口被频繁调用致CPU占用率过高排查流程","title":"进程接口被频繁调用致CPU占用率过高排查流程"},{"content":"编译AOSP source envsetup.sh lunch \u0026lt;combo\u0026gt; m -j 64 生成工程文件 source build/envsetup.sh make idegen # 或者 mmm development/tools/idegen/ # 如果提示权限问题，请用sudo执行下述命令 development/tools/idegen/idegen.sh 执行成功后，在AOSP根目录生成\nandroid.iml # 清单文件 android.ipr # 在Android studio中打开这个文件，导入源码工程 如果是在服务器上运行AS，性能足够，这一步就可以了，通过Android Studio打开android.ipr即可\n修改android.iml 增加excludeFolder列表，排除不需要的源码路径，这样可以加快导入和创建文件索引的速度。在.iml文件中有少了的excludeFolder项； \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/abi\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/art\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/bionic\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/bootable\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/build\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/cts\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/dalvik\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/developers\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/development\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/device\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/docs\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/external\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/hardware\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/kernel\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/libcore\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/libnativehelper\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/ndk\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/out\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/pdk\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/platform_testing\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/prebuilts\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/sdk\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/system\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/tools\u0026#34;/\u0026gt; \u0026lt;!-- \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/vendor\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/toolchain\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/compatibility\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/compatibility\u0026#34;/\u0026gt; \u0026lt;excludeFolder url=\u0026#34;file://$MODULE_DIR$/test\u0026#34;/\u0026gt; 删除所有\u0026hellip;项。这些项是引用的源码中编译出来的jar包，如果保留，在浏览过程中查看类型跳转到这些jar中的class文件，而不是源码java文件。删除后，则可以直接跳转到源码文件。 这些设置也可以在Android studio：project structure - project settings - modules - dependencies中修改，速度比较慢，不如直接编辑.iml文件方便\n\u0026lt;orderEntry type=\u0026#34;module-library\u0026#34;\u0026gt; \u0026lt;library\u0026gt; \u0026lt;CLASSES\u0026gt; \u0026lt;root url=\u0026#34;jar://$MODULE_DIR$/./AMSS/lagvm/LINUX/android/out/target/product/prodname/system/framework/locksettings.jar!/\u0026#34; /\u0026gt; \u0026lt;/CLASSES\u0026gt; \u0026lt;JAVADOC /\u0026gt; \u0026lt;SOURCES /\u0026gt; \u0026lt;/library\u0026gt; \u0026lt;/orderEntry\u0026gt; \u0026lt;orderEntry type=\u0026#34;module-library\u0026#34;\u0026gt; \u0026lt;library\u0026gt; \u0026lt;CLASSES\u0026gt; \u0026lt;root url=\u0026#34;jar://$MODULE_DIR$/./AMSS/lagvm/LINUX/android/out/target/product/prodname/system/framework/framework.jar!/\u0026#34; /\u0026gt; \u0026lt;/CLASSES\u0026gt; \u0026lt;JAVADOC /\u0026gt; \u0026lt;SOURCES /\u0026gt; \u0026lt;/library\u0026gt; 参考：Android studio导入Android源码（AOSP Android 14\n","permalink":"http://localhost:1313/posts/android-studio%E5%AF%BC%E5%85%A5aosp%E6%BA%90%E7%A0%81/","summary":"Android Studio导入AOSP源码","title":"Android Studio导入AOSP源码"},{"content":"前置条件 安装Android Studio； 参考1： 安装 Android Studio Android Studio 安装配置教程- Windows(详细版)-CSDN博客 adb环境变量 安装好AS之后，一般就会有adb了，通常安装在 Android SDK 目录下的 platform-tools 子文件夹，找出这个命令，并设置环境变量； Java环境 网络上一堆教程，自行设置； AVD创建 打开AS，按顺序点击图标； 选择设备定义，因为我们是做车载的，因此最好选一个平板设备，设备列表上有尺寸、分辨率和像素密度； 选择镜像，我们现在是Android 14， 对应API 34， 选择API 34的镜像； 如果这里没有下载过API 34的镜像，会出现下图中其他API一样的下载图标，下载即可； 设置设备名及相关参数，设备名自己改一下适合的，参数大致看一下，选择自己合适的即可； 点击Finish之后，AVD便创建完成了，点击运行按钮，即可打开； 编译自定义镜像 正常从AOSP获取代码即可，我这里编译的是Android 14的镜像，采用的是android14-release分支； repo init --partial-clone -b android14-release -u [https://android.googlesource.com/platform/manifest](https://android.googlesource.com/platform/manifest) repo sync -c -j8 编译： lunch 选项中， 选择SDK开头的COMBO， 这些COMBO才可以当作虚拟设备进行使用； 后面的架构具体看使用镜像的设备的架构，如Windows使用，一般选择x86_64； 其他的一些概念，md指multi display多屏，car\\pc\\phone等是指产品、portrait是默认竖屏模式等等； source build/envsetup.sh\rlunch 73. sdk_car_arm-userdebug\r74. sdk_car_arm64-userdebug\r75. sdk_car_md_x86_64-userdebug\r76. sdk_car_portrait_x86_64-userdebug\r77. sdk_car_x86-userdebug\r78. sdk_car_x86_64-userdebug\r79. sdk_pc_x86_64-userdebug 编译完成后，用以下命令进行打包，会生成对应的镜像文件，这个就是我们需要的虚拟设备的镜像文件； make emu_img_zip // Android13及以上\r// 会生成sdk-repo-linux-system-images-eng.[username]].zip文件\rmake -j32 sdk sdk_repo // Android13以下\r// 会在out/host/linux-x86/sdk/sdk_phone_x86生成\r// sdk-repo-linux-system-images-eng.[username].zip\r// repo-sys-img.xml 直接在AOSP环境使用，直接运行 如果重新进入环境，需要提前source build/envsetup.sh和lunch \u0026lt;之前对应的COMBO\u0026gt; emulator\r// 如果要使用root remount获取权限\remulator -writable-system 使用自定义的镜像 问题 从Android Studio运行的镜像，会有以下几个问题：\n比自行打开emulator会稍微卡顿一些； AS默认没有加emulator -writable-system选项，没办法获得system用户权限； AS里面都是一些预置的镜像，没有入口运行自己编译的镜像； 步骤 这里是基于Android 14的镜像进行替换，上文提到Android13以下的编译方式有所不同，不知道此方案是否一样可行\n上述我们已经拿到了所需要的自定义的镜像文件，那么就可以使用镜像文件，替代Android Studio的镜像来运行了；\n解压自定义镜像 解压sdk-repo-linux-system-images-eng.[username]].zip，结构树如下\nsdk-repo-linux-system-images-eng\r└─x86_64\r└─data\r├─media\r│ └─0\r│ └─test\r│ └─CtsMediaTestCases-1.4\r└─misc\r├─apns\r├─emulator\r│ └─config\r├─gceconfigs\r└─modem_simulator\r└─etc\r└─modem_simulator\r└─files 替换镜像 这里假设之前已经创建好了一个AVD，需要将sdk-repo-linux-system-images-eng中的x86_64，替换原本下载的API 34的镜像； 3.1 找出android sdk的位置，我这里位置是C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\ 3.2 将SDK文件夹下system-images\\android-34\\google_apis\\x86_64删除，然后替换成sdk-repo-linux-system-images-eng中的x86_64； 3.3 将SDK下的emulator文件夹，设置为环境变量；\n使用以下命令打开虚拟设备：\n// 如果emulator是环境变量，直接使用emulator命令即可；\rC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe -avd \u0026lt;之前创建的AVD设备名\u0026gt; -sysdir C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Local\\Android\\Sdk\\system-images\\android-34\\google_apis\\x86_64 -writable-system\r说明：\remulator命令\r-avd \u0026lt;之前的虚拟设备名\u0026gt;\r-sysdir \u0026lt;替换后的x86_64文件夹地址\u0026gt;\r-writable-system 允许用户进行root、remount，以便修改设备 BINGO 验证AVD镜像与本地Windows的UDP通信 参考：\n设置 Android 模拟器网络 | Android Studio UDP Android \u0026ndash;\u0026gt; PC(Windows) 测试程序-发送端 对外必须发到10.0.2.2，具体参考官网文章。10.0.2.2是对于AVD的PC的本地环回IP\nPC端 UDP 监听对应端口即可； PC(Windows) \u0026ndash;\u0026gt; Android 从PC端命令行是无法直接看到AVD的IP、端口等信息的，需要按照参考文章，进行端口映射；\n端口映射 2.1 访问控制台\nadb devices\rList of devices attached\remulator-5554 device // 这里的5554，就是AVD模拟器实例的控制台的端口；\rtelnet localhost 5554 // 通过 telnet 命令访问控制台 2.2 进入控制台后，第一步是需要先认证，否则能看到的命令就只有如下几个，没有redir命令\nAndroid Console: Authentication required\rAndroid Console: type \u0026#39;auth \u0026lt;auth_token\u0026gt;\u0026#39; to authenticate\rAndroid Console: you can find your \u0026lt;auth_token\u0026gt; in\r\u0026#39;C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token\u0026#39;\rOK\rhelp\rAndroid console commands:\rhelp|h|?\rhelp-verbose\rping\ravd\rauth\rquit|exit\rTry \u0026#39;help-verbose\u0026#39; for more description\rTry \u0026#39;help \u0026lt;command\u0026gt;\u0026#39; for command-specific help\rOK 2.3 控制台认证，认证的方式就是如提示所示，查看C:\\Users\\\u0026lt;user\u0026gt;\\.emulator_console_auth_token文件的token，然后用auth命令进行认证； 认证之后，才可以进行更高权限的操作\nauth FQn7ZW+ePZmQZ4hJ\rAndroid Console: type \u0026#39;help\u0026#39; for a list of commands\rOK 2.4 端口映射 redir add \u0026lt;协议类型\u0026gt; PC端口：AVD端口\nredir add tcp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限TCP协议\rredir add udp:5000:6000 // 这个的意思是将PC端的5000端口，映射到AVD的6000端口，仅限UDP协议 接下来PC只需要发到本地的对应的PC端口，然后AVD中apk监听映射后的端口即可 测试工具 测试工具是一个桌面端工具和一个APK 测试工具：https://github.com/uname/PySockDebuger/releases/tag/1.0Beta 可以用于桌面端模拟UDP发送和接收 APK 3.1 安装 adb install -t \u0026lt;apk路径\u0026gt;\r// 出现Success字样即说明安装成功 3.2 通过AVD点击图标打开 默认接收端口为12346，不可更改（验证接收前，请按照[[自定义AVD镜像搭建和UDP通信验证#PC(Windows) \u0026ndash;\u0026gt; Android]]进行端口转发） 可以自行输入发送端口和消息进行发送，发送IP必须是10.0.2.2\n附笔记： 测试程序-发送端 new Thread(new UdpSendRunnable()).start(); private class UdpSendRunnable implements Runnable { @Override public void run() { while (true) { try (DatagramSocket socket = new DatagramSocket()) { byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: Hello\u0026#34;); DatagramPacket packet = new DatagramPacket(data, data.length, InetAddress.getByName(\u0026#34;10.0.2.2\u0026#34;), 12346); socket.send(packet); // 直接发送 sleep(1000); } catch (IOException | InterruptedException e) { Log.i(\u0026#34;MAXZ\u0026#34;, \u0026#34;run: \u0026#34; + e); throw new RuntimeException(e); } } } } 测试程序-接收端 public static void main(String[] args) throws IOException { DatagramSocket socket = null; try { socket = new DatagramSocket(12346); } catch (SocketException e) { throw new RuntimeException(e); } byte[] buffer = new byte[1024]; while (true) { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); socket.receive(packet); // 阻塞等待数据 String message = new String(packet.getData(), 0, packet.getLength()); String displayText = \u0026#34;Received: \u0026#34; + message + \u0026#34;\\nFrom: \u0026#34; + packet.getAddress(); System.out.println(displayText); } } ","permalink":"http://localhost:1313/posts/%E8%87%AA%E5%AE%9A%E4%B9%89avd%E9%95%9C%E5%83%8F%E6%90%AD%E5%BB%BA%E5%92%8Cavd%E4%B8%8E%E4%B8%BB%E6%9C%BAudp%E9%80%9A%E4%BF%A1/","summary":"使用自编译的AVD镜像，并验证与主机的UDP通信","title":"自定义AVD镜像搭建和AVD与主机UDP通信"},{"content":"AOSP编译错误：Ninja Failed With Signal Killed 原因和解决办法：线程太多导致 网络上大部分的原因基本上都是Android服务器环境内存不足，需要检查内存或者通过检查内存交换区来进行解决；然而在这里不起作用。\n在ninja killed的时候，部分时候Ubuntu的确是卡顿或者卡死的， VMWare分配了32GB内存，且基本上没有开太多的任务，因此不是内存的原因。\n我是通过写了个简单的脚本进行编译的，这里-j线程改成了16，后面改成8就OK了，估计是线程太多导致Linux卡顿，系统杀死卡顿进程导致。\nsource build/envsetup.sh lunch aosp_arm64-trunk_staging-eng make -j16 2\u0026gt;\u0026amp;1 |tee build2.log 网上其他原因以及解决办法 网络上大部分是因为内存问题导致，通过新建内存交换区解决。\n#!/bin/bash # 建立swap文件 # 查看目前swap free -m # 建立swap文件,大小4G dd if=/dev/zero of=/var/swapfile bs=1024 count=4000000 # 启用虚拟内存,将swap文件设置为swap分区文件 mkswap /var/swapfile #注意：insecure permissions 0644, 0600 suggested. chmod 600 /var/swapfile # 激活swap,启用分区交换文件 swapon /var/swapfile # 停用虚拟内存 #swapoff /var/swapfile # 查看内存和虚拟内存 free -m # 开机启用swap echo \u0026#39;/var/swapfile swap swap defaults 0 0\u0026#39; \u0026gt;\u0026gt; /etc/fstab # 查看目前swap free -m FAILED: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib OUT_DIR=out ANDROID_RUST_VERSION=1.78.0 CARGO_CRATE_NAME=devices CARGO_PKG_NAME=devices CARGO_PKG_VERSION=0.1.0 CARGO_PKG_VERSION_MAJOR=0 CARGO_PKG_VERSION_MINOR=1 CARGO_PKG_VERSION_PATCH=0 prebuilts/rust/linux-x86/1.78.0/bin/rustc -C linker=prebuilts/clang/host/linux-x86/clang-r522817/bin/clang++ -C link-args=\u0026#34; -Wl,--as-needed -target aarch64-linux-android - # ... out/soong/.intermediates/external/crosvm/net_util/libnet_util/android_arm64_armv8-a_rlib_rlib-std_apex10000/582736703e6423fcea154bd3703d3915/ -Z stack-protector=strong -Z remap-cwd-prefix=. -C debuginfo=2 -C opt-level=3 -C relocation-model=pic -C overflow-checks=on -C force-unwind-tables=yes -C symbol-mangling-version=v0 --color=always -Z dylib-lto -Z link-native-libraries=no --cfg soong -C force-frame-pointers=y -C panic=abort -Z debug-info-for-profiling -Z tls-model=global-dynamic --cap-lints allow --edition=2021 -C metadata=libdevices --cfg \u0026#39;feature=\u0026#34;android_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;android_display_stub\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;audio_aaudio\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;balloon\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;geniezone\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gfxstream\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gpu_display\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;gunyah\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;net\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;usb\u0026#34;\u0026#39; --cfg \u0026#39;feature=\u0026#34;virgl_renderer\u0026#34;\u0026#39; --crate-type=rlib --crate-name=devices --target=aarch64-linux-android --sysroot=/dev/null -C codegen-units=1 \u0026amp;\u0026amp; grep ^out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib: out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d.raw \u0026gt; out/soong/.intermediates/external/crosvm/devices/libdevices/android_arm64_armv8-a_rlib_rlib-std_apex10000/7911d933735aaf6db37b7bd96172f083/libdevices.rlib.d error: failed to build archive: No such file or directory error: aborting due to 1 previous error ... ninja: build stopped: subcommand failed. 03:49:38 ninja failed with: exit status 1 #### failed to build some targets (12:25 (mm:ss)) #### ","permalink":"http://localhost:1313/posts/%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99-ninja-failed-with-signal-killed/","summary":"AOSP编译错误：Ninja Failed With Signal Killed","title":"编译报错 Ninja Failed With Signal Killed"},{"content":"WSL2编译AOSP笔记 学了这么久，虽然是已经非常熟练的操作，但还是需要记录一下\u0026hellip;\n为什么选择WSL2，不选择VMWare，因为VMWare占用的资源太大了，WSL2对比下来，发现轻松很多。而且也方便用AS等软件直接打开源码。\n相关概念 WSL2，Windows Subsystem for Linux，Windows操作系统上的一个功能，用来允许在Windows运行Linux环境； AOSP，额看这篇笔记的应该都懂，Android Open Source Project， 主要指Android开源代码； 步骤 WSL2安装和初始化 安装 以 管理员身份 打开 PowerShell。\n方法：在开始菜单搜索 \u0026ldquo;PowerShell\u0026rdquo;，右键点击，选择“以管理员身份运行”。 在 PowerShell 窗口中，输入以下命令并回车：\nPowerShell\nwsl --install 这条命令会自动帮你完成以下所有事情：\n开启 “虚拟机平台” 功能。 开启 “适用于 Linux 的 Windows 子系统” 功能。 下载并安装 最新版的 Linux 内核。 设置 WSL2 为默认版本。 从微软商店下载并安装 最新版的 Ubuntu 发行版。 命令运行完毕后，重启电脑。\nUbuntu初始化 搜索打开Ubuntu，或者在Terminal选项中打开； 第一次启动会提示：\u0026ldquo;Installing, this may take a few minutes\u0026hellip;\u0026quot;； 安装完成后，创建初始账号和密码； 验证WSL版本 打开PowerShell，输入以下 wsl -l -v 你会看到类似输出： NAME STATE VERSION * Ubuntu Running 2 如果 VERSION 列显示为 2，说明一切正常，你已经成功用上了 WSL2。\n【转换操作】 如果 VERSION 列显示为 1，说明这是一个 WSL1 的旧实例，你需要手动将其转换为 WSL2。执行以下命令即可：\nPowerShell\n# 把 \u0026#34;Ubuntu\u0026#34; 替换成你列表中显示的名字 wsl --set-version Ubuntu 2 等待转换完成后，你的 Ubuntu 就成功升级到 WSL2 了。\nAOSP下载和编译 参考官网：Try Android development | Android Open Source Project\n安装所需软件 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev libc6-dev-i386 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig 注意一下，需要每个都安装成功\n安装repo 安装repo有2种方式，一种是直接sudo apt install repo，但是一般这样安装，repo的版本都比较低，我一般通过源码进行安装；\nexport REPO=$(mktemp /tmp/repo.XXXXXXXXX) curl -o ${REPO} https://storage.googleapis.com/git-repo-downloads/repo gpg --recv-keys 8BB9AD793E8E6153AF0F9A4416530D5E920F5C65 curl -s https://storage.googleapis.com/git-repo-downloads/repo.asc | gpg --verify - ${REPO} \u0026amp;\u0026amp; install -m 755 ${REPO} ~/bin/repo 查看repo版本\nrepo version 下载源码 repo init --partial-clone -b android-latest-release -u https://android.googlesource.com/platform/manifest # 这里是android新出的manifest名称，用android-latest-release替代main，来代表最新的释放版本； # 也可以通过AOSP官网查看其他manifest分支 # --partial-clone 这个选项是Android用来替代--depth=1选项的，这个会智能地下载历史记录，但不会立马下载一些非必要的文件，只有在真正下载用到的时候才会进行下载源码 repo sync -c --no-tags --prune -j16 编译源码 source build/envsetup.sh lunch \u0026lt;COMBO\u0026gt; # COMBO一般我编译sdk_car_x86_64-aosp_current-eng m -j32 # -j是线程数，看你自己的CPU来确定，如果线程数太高，可能会编译失败，甚至ninja由于线程数过高直接被kill掉，这种情况连报错都不会显示 启动 emulator即可。需要注意，如果只是输入emulator，它会根据环境变量去找对应的镜像，需要先source envsetup.sh和lunch；\nemulator ","permalink":"http://localhost:1313/posts/wls2%E7%BC%96%E8%AF%91aosp%E7%AC%94%E8%AE%B0/","summary":"WSL2编译AOSP的笔记","title":"WLS2编译AOSP笔记"},{"content":"WEEK 39 周报 Android 搭建WSL2 + Ubuntu； 完成编译AOSP，版本为android15； ","permalink":"http://localhost:1313/posts/weekly/2025-week-39/","summary":"第39周周报","title":"2025 Week 39"},{"content":"WEEK 38 周报 博客搭建 BLOG搭建 Github Pages + Hugo 初始化 PaperMod主题配置 首页、归档、搜索、TAG等功能配置 ","permalink":"http://localhost:1313/posts/weekly/2025-week-38/","summary":"第38周周报","title":"2025 Week 38"},{"content":"技术栈：Hugo + Git + GitHub Pages + GitHub Actions\n主题：PaperMod Theme\n初始化Github Pages和Hugo 创建仓库 仓库名字一定要按照\u0026lt;UserName\u0026gt;.github.io创建 克隆仓库 git clone \u0026lt;仓库地址\u0026gt; git clone https://github.com/MaxJ-L/MaxJ-L.github.io.git hugo安装 进入Releases · gohugoio/hugo hugo官方Github网址，通过release下载对应系统的执行文件； 将hugo配置为环境变量； hugo初始化 使用以下命令在当前目录进行初始化\n一般其实采用hugo new site 进行初始化\n但是实际操作发现以下冲突：\ngit clone会自动创建文件夹； hugo new site 会自动创建BLOG NAME的文件夹； 以上这两个文件夹会冲突（clone不允许同名文件夹、如果不在根目录new site，会导致无法正常现实）\n当然其实这些问题肯定可以通过配置其他文件进行规避的，但是修改和熟悉成本就高很多了\nhugo new site . --force 初始化之后，会出现以下目录\nMaxJ-L.github.io.git ├─archetypes // 内容模板文件夹。运行 `hugo new` 时，会使用这里的模板来创建新文件 │ default.md // 内容“模板”，运行 `hugo new` 时会基于此文件创建新文章的结构。 ├─assets // 资源文件夹。存放需要 Hugo 处理的文件，如 SCSS、需要压缩的 JS 等 ├─content // 内容文件夹。你所有的博客文章、页面等 .md 文件都存放在这里，是网站的核心 ├─data // 数据文件夹。存放 JSON, YAML, TOML 等格式的数据文件，供模板调用。 ├─i18n // 国际化文件夹。用于存放多语言网站的翻译字符串。 ├─layouts // 布局文件夹。用于存放自定义的 HTML 模板，可以覆盖主题的默认布局。 ├─public // 输出文件夹。运行 `hugo` 命令后，生成的完整静态网站会放在这里。这是最终部署的“成品”。 ├─static // 静态文件夹。存放无需处理的文件，如图片、CSS、字体等。会原样复制到最终网站。 └─themes // 主题文件夹。存放你下载的网站主题，比如 PaperMod。 hugo.toml // 网站的“大脑”，最重要的全局配置文件，包含网址、主题、菜单等所有设置。 主题安装与核心配置 主题安装 Hugo Themes网站上面有许多主题，可以自行跳转主题进行下载；\n我选择的是PaperMod，进入对应的Github地址adityatelange/hugo-PaperMod: A fast, clean, responsive Hugo theme.\n根据Installation · adityatelange/hugo-PaperMod Wiki上面对应的安装方法； 我使用推荐的方法2进行安装 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) git submodule update --remote --merge 核心配置 hugo.toml baseURL = \u0026#34;https://MaxJ-L.github.io/\u0026#34; ## 这里是你的仓库Github Pages地址 languageCode = \u0026#39;zh-CN\u0026#39; ## 这里配置成对应的语言 theme = \u0026#39;PaperMod\u0026#39; ## 这里配置成你选中的主题，我这里选择了PaperMod title = \u0026#39;The MaxJ-L Stack\u0026#39; ## 这里是BLOG的标题 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] # -- 导航栏菜单配置 -- # 导航栏需要显式配置归档、搜索和标签，才可以显示。如果不配置，打开之后只显示主页 [[menu.main]] identifier = \u0026#34;archives\u0026#34; name = \u0026#34;归档\u0026#34; url = \u0026#34;/archives/\u0026#34; # 链接到我们刚刚创建的 archives.md weight = 10 # 权重，数字越小越靠前 [[menu.main]] identifier = \u0026#34;search\u0026#34; name = \u0026#34;搜索\u0026#34; url = \u0026#34;/search/\u0026#34; weight = 20 [[menu.main]] identifier = \u0026#34;tags\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; weight = 30 在content下面创建archives.md和search.md，然后补充内容 --- title: \u0026#34;Archives\u0026#34; layout: \u0026#34;archives\u0026#34; # archives.md` # 不要改动这个文件的其他内容 --- --- title: \u0026#34;Search\u0026#34; layout: \u0026#34;search\u0026#34; # search.md # 不要改动这个文件的其他内容 --- Hugo 本地调试 hugo server 如果显示如下，则说明没有错误，打开 http://localhost:1313/ 即可；\n如果有语法错误，会有提示；\n│ EN ─────────┼── Pages │ 13 Paginator pages │ 0 Non-page files │ 0 Static files │ 0 Processed images │ 0 Aliases │ 2 Cleaned │ 0 Built in 230 ms Environment: \u0026#34;development\u0026#34; Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop PUSH到远程仓库并且实现CI/CD自动化部署 目的是实现PUSH的时候自动触发deploy部署\npush到远程仓库 git add . git commit -m \u0026#34;First Add\u0026#34; git push origin main Github Actions自动化部署 方案1 手动创建文件 根目录手动创建文件.github/workflows/hugo.yml 填充以下内容 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: [\u0026#34;main\u0026#34;] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.150.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: HUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache HUGO_ENVIRONMENT: production run: | hugo \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 方案2 页面配置 进入仓库页面，依次点击Actions、New workflow进入选择workflow页面； workflow页面搜索hugo，点击Configure； 显示以下页面，修改内容，然后点击Commit changes... 这里有个坑：ParperMod对hugo版本号有要求\nhugo v0.146.0 or greater is required for hugo-PaperMod to build\n因此模板那里需要修改一下版本号\n感谢 如何用 GitHub Pages + Hugo 搭建个人博客 · KrislinBlog\n","permalink":"http://localhost:1313/posts/githubpages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","summary":"Hugo + GitHub Pages 博客搭建全攻略：从入门到自动化部署（含踩坑笔记）","title":"GithubPages搭建个人博客教程"},{"content":" 从网络上拉取代码，容易受当时网络影响，对一些大仓库不一定能够拉取成功；因此可以通过拷贝现有.repo文件夹，来快速搭建编译环境\n核心步骤 原有编译环境 tar -cvf repo.tgz .repo 将repo.tgz想办法拷贝到需要运行的工作站/服务器；\n解压repo.tgz\ntar -xvf repo.tgz repo sync 进一步改进 方式1：将.repo每天定时更新、压缩并放到公共云盘，编译脚本通过公共云盘进行下载； 方式2：搭建本地代理仓库，将里面的仓库改为本地代理仓库； 时间统计估算 不同环境网速不一样，这个是自己工作环境的速度\n通过传统拉取编译代码方式，拉取整个仓库代码在大半天~几天不等，具体视网络情况而定 通过拷贝.repo，亲测时间如下： repo.tgz打包，没有仔细估算，约15~25分钟 repo.tgz拷贝到本地，本地上传到Docker（30min + 30min，后续通过命令直接传输两个服务器的文件，可以减少为一次拷贝，估算30min） Repo sync，估算约30min 整个流程在1~2h内可以搭建一套最新的编译环境 ","permalink":"http://localhost:1313/posts/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E5%BF%AB%E9%80%9F%E6%8B%89%E5%8F%96.repo%E6%90%AD%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/","summary":"开发技巧：快速拉取.repo搭建编译环境","title":"开发技巧：快速拉取.repo搭建编译环境"},{"content":"Issue source build/envsetup.sh和lunch`后，无法显示menu；\nYou\u0026#39;re building on Linux Warning: Cannot display lunch menu. Note: You can invoke lunch with an explicit target: usage: lunch [target] Which would you like? [aosp_cf_x86_64_phone-trunk_staging-eng] Pick from common choices above (e.g. 13) or specify your own (e.g. aosp_barbet-trunk_staging-eng): Fixed 疑似因为部分环境变量没有提前设置好，因此导致了此错误。\n大部分情况根据这个步骤，可以解决\n. ./build/envsetup.sh export TARGET_RELEASE=trunk_staging OR export TARGET_RELEASE=ap1a # (as shown in your quoted error) build_build_var_cache lunch Preferences lunch failed | Page 2 | XDA Forums ","permalink":"http://localhost:1313/posts/android-15.0.0_r1-lunch%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAmenu.md/","summary":"Android-15.0.0_r1 lunch无法显示menu.md","title":"Android-15.0.0_r1 lunch无法显示menu.md"},{"content":"在使用CarLauncher的时候，因为CarLauncher背景非透明颜色，导致无法看到壁纸；因此设置了以下几个属性\n\u0026lt;activity android:theme=\u0026#34;@style/Theme.Launcher.HomeActivity\u0026#34;/\u0026gt; \u0026lt;style name=\u0026#34;Theme.Launcher.HomeActivity\u0026#34; parent=\u0026#34;Theme.CarUi.NoToolbar\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:background\u0026#34;\u0026gt;@color/transparent\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowIsTranslucent\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 但是，设置属性之后，出现无法切换会主页的情况。随后网上查询得知android:windowIsTranslucent经常会导致activity无法正常走生命流程；\nPreferences windowIsTranlucent 踩坑之旅; Activity Lifecycle in Android; In-depth analysis of Activity\u0026rsquo;s Lifecycle | by Abhilash Das; ","permalink":"http://localhost:1313/posts/android-windowistranslucent%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%88%87%E6%8D%A2activity/","summary":"Android windowIsTranslucent导致无法切换activity","title":"Android windowIsTranslucent导致无法切换activity"}]